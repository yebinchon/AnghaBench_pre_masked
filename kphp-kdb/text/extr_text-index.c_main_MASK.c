
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_17__ TYPE_9__ ;
typedef struct TYPE_16__ TYPE_4__ ;
typedef struct TYPE_15__ TYPE_3__ ;
typedef struct TYPE_14__ TYPE_2__ ;
typedef struct TYPE_13__ TYPE_1__ ;
typedef struct TYPE_12__ TYPE_10__ ;


struct message {int dummy; } ;
struct buff_file {char* filename; int crc32; int wpos; int fd; } ;
struct TYPE_17__ {void* A; } ;
struct TYPE_16__ {char* replica_prefix; } ;
struct TYPE_15__ {TYPE_1__* info; } ;
struct TYPE_14__ {int replica_prefix; } ;
struct TYPE_13__ {char* filename; int file_size; } ;
struct TYPE_12__ {void* A; } ;


 TYPE_3__* VAR_0 ;
 int VAR_1 ;
 int VAR_2 ;
 int VAR_3 ;
 int VAR_4 ;
 void* VAR_5 ;
 TYPE_10__ VAR_6 ;
 int VAR_7 ;
 TYPE_9__ VAR_8 ;
 int VAR_9 ;
 int VAR_10 ;
 int VAR_11 ;
 int FUNC_0 (int) ;
 int FUNC_1 (void*) ;
 int FUNC_2 (void*) ;
 int VAR_12 ;
 int VAR_13 ;
 scalar_t__ VAR_14 ;
 char* VAR_15 ;
 int FUNC_3 () ;
 int VAR_16 ;
 int VAR_17 ;
 int VAR_18 ;
 scalar_t__ FUNC_4 (char*) ;
 int FUNC_5 () ;
 int FUNC_6 (int ) ;
 int FUNC_7 (TYPE_3__*,int) ;
 int FUNC_8 (int) ;
 int FUNC_9 () ;
 int VAR_19 ;
 int VAR_20 ;
 int VAR_21 ;
 int VAR_22 ;
 int VAR_23 ;
 scalar_t__ VAR_24 ;
 scalar_t__ VAR_25 ;
 scalar_t__ VAR_26 ;
 int FUNC_10 (int ) ;
 int FUNC_11 (int ) ;
 long long VAR_27 ;
 int FUNC_12 () ;
 int FUNC_13 () ;
 scalar_t__ FUNC_14 (char*,char*) ;
 TYPE_4__* VAR_28 ;
 TYPE_2__* VAR_29 ;
 int FUNC_15 () ;
 int FUNC_16 (int) ;
 int * VAR_30 ;
 int FUNC_17 () ;
 int VAR_31 ;
 int FUNC_18 (int ,char*,...) ;
 scalar_t__ FUNC_19 (int ) ;
 char* FUNC_20 (TYPE_2__*,int ,int ) ;
 int FUNC_21 (int ) ;
 int FUNC_22 (int,char**,char*) ;
 int VAR_32 ;
 int VAR_33 ;
 int VAR_34 ;
 int FUNC_23 () ;
 int FUNC_24 () ;
 int FUNC_25 () ;
 int FUNC_26 (int ,int ,int ) ;
 int VAR_35 ;
 int VAR_36 ;
 void* VAR_37 ;
 scalar_t__ FUNC_27 (int ,int ) ;
 int VAR_38 ;
 int FUNC_28 () ;
 int VAR_39 ;
 int VAR_40 ;
 scalar_t__ VAR_41 ;
 int VAR_42 ;
 int FUNC_29 (int ,int ,int ) ;
 void* FUNC_30 (int) ;
 int VAR_43 ;
 int VAR_44 ;
 int VAR_45 ;
 char* VAR_46 ;
 TYPE_3__* FUNC_31 (TYPE_4__*,int ) ;
 int FUNC_32 (int ,char*,int) ;
 int FUNC_33 () ;
 void* VAR_47 ;
 int VAR_48 ;
 int FUNC_34 () ;
 int VAR_49 ;
 int* VAR_50 ;
 int VAR_51 ;
 void* VAR_52 ;
 int FUNC_35 () ;
 int FUNC_36 () ;
 int FUNC_37 () ;
 int VAR_53 ;
 int FUNC_38 (char*) ;
 int FUNC_39 () ;
 int VAR_54 ;
 int VAR_55 ;
 int VAR_56 ;
 char* VAR_57 ;
 scalar_t__ FUNC_40 (char*) ;
 int VAR_58 ;
 int VAR_59 ;
 int VAR_60 ;
 int FUNC_41 (int ,int) ;
 int VAR_61 ;
 int VAR_62 ;
 int VAR_63 ;
 int FUNC_42 () ;
 int FUNC_43 (int ,int ) ;
 int FUNC_44 (void*,char*,long long*,char*) ;
 int VAR_64 ;
 int FUNC_45 () ;
 int FUNC_46 (void*) ;
 void* VAR_65 ;
 struct buff_file* VAR_66 ;
 int FUNC_47 () ;
 int VAR_67 ;
 int VAR_68 ;
 void* VAR_69 ;
 int FUNC_48 () ;
 int FUNC_49 (char*) ;
 scalar_t__ FUNC_50 (TYPE_2__*,int) ;
 int FUNC_51 () ;
 int VAR_70 ;
 char* VAR_71 ;
 scalar_t__ VAR_72 ;
 int VAR_73 ;
 int FUNC_52 () ;
 int FUNC_53 () ;
 int FUNC_54 () ;
 int FUNC_55 () ;
 int FUNC_56 () ;

int FUNC_57 (int VAR_74, char *VAR_75[]) {
  int VAR_76;
  char VAR_77;
  long long VAR_78;

  FUNC_42();

  VAR_57 = VAR_75[0];
  while ((VAR_76 = FUNC_22 (VAR_74, VAR_75, "a:f:iStqspehu:mvyUGL:T:Z:")) != -1) {
    switch (VAR_76) {
    case 'e':
      VAR_51 = -1;
    case 'v':
      VAR_72++;
      break;
    case 'h':
      FUNC_51 ();
      return 2;
    case 'u':
      VAR_71 = VAR_47;
      break;
    case 'a':
      VAR_15 = VAR_47;
      break;
    case 'i':
      VAR_62 = 1;
      break;
    case 'y':
      VAR_33 = 1;
      break;
    case 's':
      VAR_45 = 1;
      break;
    case 'S':
      VAR_70 = 1;
      break;
    case 'U':
      VAR_73 = 1;
      break;
    case 't':
      VAR_32 = 1;
      break;
    case 'q':
      VAR_63 = 1;
      break;
    case 'G':
      VAR_34 = 1;
      break;
    case 'p':
      VAR_53 = 1;
      break;
    case 'f':
      VAR_43 = FUNC_1 (VAR_47);
      if (VAR_43 < 0 || VAR_43 > 100) {
        VAR_43 = VAR_3;
      }
      break;
    case 'm':
      VAR_31 = 1;
      break;
    case 'Z':
      VAR_77 = 0;
      FUNC_0 (FUNC_44 (VAR_47, "%lld%c", &VAR_78, &VAR_77) >= 1);
      switch (VAR_77 | 0x20) {
      case 'k': VAR_78 <<= 10; break;
      case 'm': VAR_78 <<= 20; break;
      case 'g': VAR_78 <<= 30; break;
      case 't': VAR_78 <<= 40; break;
      default: FUNC_0 (VAR_77 == 0x20);
      }
      if (VAR_78 >= (1LL << 20) && VAR_78 <= (sizeof(long) == 4 ? (3LL << 30) : (20LL << 30))) {
        VAR_27 = VAR_78;
      }
      break;
    case 'T':
      if (FUNC_46 (VAR_47) < 120) {
 VAR_65 = VAR_47;
      }
      break;
    case 'L':
      VAR_40 = FUNC_2 (VAR_47);
      break;
    }
  }
  if (VAR_74 != VAR_48 + 1 || (VAR_70 && !VAR_62)) {
    FUNC_51();
    return 2;
  }

  if (FUNC_4 (VAR_71) < 0) {
    FUNC_18 (VAR_64, "fatal: cannot change user to %s\n", VAR_71 ? VAR_71 : "(none)");
    FUNC_16 (1);
  }

  if (!VAR_62) {
    VAR_32 = VAR_63 = 0;
  }

  FUNC_24 ();
  if (VAR_32) {
    FUNC_12 ();
  }
  if (VAR_63) {
    FUNC_13 ();
  }
  FUNC_25 ();
  if (VAR_70) {
    FUNC_45 ();
  }

  FUNC_23();

  VAR_5 = FUNC_30 (sizeof (struct message *) * VAR_4);
  VAR_52 = FUNC_30 (sizeof (int) * VAR_4 * 2);
  VAR_37 = FUNC_30 (sizeof (int) * VAR_4 * 3);
  FUNC_0 (VAR_5 && VAR_52 && VAR_37);

  VAR_8.A = FUNC_30 (VAR_7 * sizeof (void *));
  VAR_6.A = FUNC_30 (VAR_7 * sizeof (void *));
  FUNC_0 (VAR_8.A && VAR_6.A);

  if (FUNC_14 (VAR_75[VAR_48], VAR_15) < 0) {
    FUNC_18 (VAR_64, "cannot open binlog files for %s\n", VAR_15 ? VAR_15 : VAR_75[VAR_48]);
    FUNC_16 (1);
  }

  VAR_0 = FUNC_31 (VAR_28, 0);
  if (!VAR_0) {
    FUNC_18 (VAR_64, "fatal: cannot find binlog for %s\n", VAR_28->replica_prefix);
    FUNC_16 (1);
  }

  VAR_15 = VAR_0->info->filename;

  if (VAR_72) {
    FUNC_18 (VAR_64, "replaying binlog file %s (size %d)\n", VAR_15, VAR_0->info->file_size);
  }

  VAR_12 = FUNC_21 (VAR_1);

  FUNC_5();
  FUNC_26 (0, 0, 0);

  VAR_54 = VAR_55;
  VAR_9 = VAR_10;
  VAR_16 = VAR_17;
  VAR_21 = VAR_22;
  VAR_58 = VAR_59;

  VAR_76 = FUNC_41 (0, 1);

  VAR_12 = FUNC_21 (VAR_1) - VAR_12;
  VAR_13 = VAR_42;

  FUNC_7 (VAR_0, 1);

  FUNC_0 (VAR_40 < 0 || VAR_42 == VAR_40);
  VAR_40 = VAR_42;
  VAR_39 = ~VAR_38;
  VAR_36 = VAR_35;

  if (VAR_76 < 0) {
    FUNC_18 (VAR_64, "fatal: error reading binlog\n");
    FUNC_16 (1);
  }

  if (VAR_72) {
      FUNC_18 (VAR_64, "replay binlog file: done, pos=%lld, last_global_id=%d, alloc_mem=%ld out of %ld, time %.6ds\n",
        (long long) VAR_41, VAR_35, (long) (VAR_24 - VAR_25), (long) (VAR_26 - VAR_25), VAR_12);
  }

  if (VAR_62 && VAR_72 > 0) {
    FUNC_47 ();
  }

  FUNC_35 ();
  FUNC_9 ();
  FUNC_3 ();

  if (VAR_51 < 0) {
    FUNC_34 ();
    return 0;
  }

  VAR_51 = FUNC_15 ();
  if (VAR_72 > 0) {
    FUNC_18 (VAR_64, "%ld bytes available for indexing, will need %d passes\n", (long) (VAR_26 - VAR_24), VAR_51);
  }

  if (VAR_29) {
    FUNC_0 (FUNC_50 (VAR_29, 1) > 0);
    VAR_46 = FUNC_20 (VAR_29, FUNC_28(), VAR_29->replica_prefix);
  }

  if (!VAR_46 || VAR_46[0] == '-') {
    FUNC_18 (VAR_64, "cannot write index: cannot compute its name\n");
    FUNC_16 (1);
  }

  FUNC_32 (0, VAR_46, 1);
  FUNC_0 (FUNC_27 (VAR_30[0], VAR_2) > 0);

  FUNC_53 ();
  FUNC_55 ();
  FUNC_52 ();
  FUNC_37 ();

  FUNC_36 ();

  if (VAR_65) {
    if (VAR_72 > 0) {
      FUNC_18 (VAR_64, "running splitting pass to create temporary files\n");
    }

    VAR_0 = FUNC_31 (VAR_28, 0);
    if (!VAR_0) {
      FUNC_18 (VAR_64, "fatal: cannot find binlog for %s\n", VAR_28->replica_prefix);
      FUNC_16 (1);
    }

    VAR_15 = VAR_0->info->filename;

    if (VAR_72) {
      FUNC_18 (VAR_64, "replaying binlog file %s (size %d)\n", VAR_15, VAR_0->info->file_size);
    }

    FUNC_10 (0);
    FUNC_33 ();

    FUNC_5();
    FUNC_26 (0, 0, 0);
    VAR_61 = VAR_68;
    VAR_35 = 0;

    VAR_12 = FUNC_21(VAR_1);

    VAR_76 = FUNC_41 (0, 1);

    VAR_12 = FUNC_21(VAR_1) - VAR_12;
    VAR_61 = VAR_67;

    if (VAR_76 < 0) {
      FUNC_18 (VAR_64, "fatal: error reading binlog\n");
      FUNC_16 (1);
    }
    if (VAR_72) {
        FUNC_18 (VAR_64, "replay binlog file (pass %d): done, alloc_mem=%ld out of %ld, time %.6ds\n",
          VAR_49, (long) (VAR_24 - VAR_25), (long) (VAR_26 - VAR_25), VAR_12);
    }

    FUNC_7 (VAR_0, 1);
    VAR_0 = 0;

    if (VAR_35 != VAR_36) {
      FUNC_18 (VAR_64, "last global id mismatch: original pass %d, current pass %d\n", VAR_36, VAR_35);
    }
    FUNC_0 (VAR_39 == ~VAR_38 && VAR_35 == VAR_36);

    FUNC_48 ();

    FUNC_11 (0);
  }

  for (VAR_49 = 1; VAR_49 <= VAR_51; VAR_49++) {
    struct buff_file *VAR_79 = 0;
    VAR_20 = VAR_50[VAR_49 - 1];
    VAR_19 = VAR_50[VAR_49];
    if (VAR_72 > 0) {
      FUNC_34 ();
      FUNC_18 (VAR_64, "starting pass #%d, uid %d..%d\n", VAR_49, VAR_20, VAR_19);
    }

    if (!VAR_65) {
      VAR_0 = FUNC_31 (VAR_28, 0);
      if (!VAR_0) {
 FUNC_18 (VAR_64, "fatal: cannot find binlog for %s\n", VAR_28->replica_prefix);
 FUNC_16 (1);
      }

      VAR_15 = VAR_0->info->filename;

      if (VAR_72) {
 FUNC_18 (VAR_64, "replaying binlog file %s (size %d)\n", VAR_15, VAR_0->info->file_size);
      }
      FUNC_5 ();
      FUNC_26 (0, 0, 0);
    } else {
      VAR_79 = &VAR_66[VAR_49 - 1];
      FUNC_5 ();
      VAR_14 = 0;
      VAR_15 = VAR_79->filename;
      FUNC_43 (VAR_79->fd, VAR_79->wpos);
      FUNC_29 (0, 0, 0);
      VAR_40 = -1;
    }

    FUNC_10 (0);

    VAR_35 = 0;
    VAR_69 = (void *) -1;

    VAR_54 = VAR_56;
    VAR_9 = VAR_11;
    VAR_16 = VAR_18;
    VAR_21 = VAR_23;
    VAR_58 = VAR_60;

    VAR_12 = FUNC_21(VAR_1);

    VAR_76 = FUNC_41 (0, 1);

    VAR_12 = FUNC_21(VAR_1) - VAR_12;

    if (VAR_76 < 0) {
      FUNC_18 (VAR_64, "fatal: error reading binlog\n");
      FUNC_8 (3);
      FUNC_16 (1);
    }
    if (VAR_72) {
        FUNC_18 (VAR_64, "replay binlog file %s (pass %d): done, alloc_mem=%ld out of %ld, time %.6ds\n",
          VAR_15, VAR_49, (long) (VAR_24 - VAR_25), (long) (VAR_26 - VAR_25), VAR_12);
    }

    if (!VAR_65) {
      FUNC_7 (VAR_0, 1);
      FUNC_0 (VAR_39 == ~VAR_38);
    } else {
      FUNC_0 (VAR_79->crc32 = ~VAR_38);
    }

    FUNC_39 ();

    FUNC_11 (0);

    if (VAR_35 != VAR_36) {
      FUNC_18 (VAR_64, "last global id mismatch: original pass %d, current pass %d\n", VAR_36, VAR_35);
    }
    FUNC_0 (VAR_35 == VAR_36);
  }

  if (VAR_65) {
    FUNC_8 (3);
  }

  FUNC_0 (VAR_19 == VAR_44 + 1);

  FUNC_56 ();
  FUNC_54 ();

  FUNC_17 ();

  FUNC_0 (FUNC_19(VAR_30[0]) >= 0);
  FUNC_6 (VAR_30[0]);

  if (FUNC_40 (VAR_46)) {
    FUNC_18 (VAR_64, "cannot rename new index file from %s: %m\n", VAR_46);
    FUNC_49 (VAR_46);
    FUNC_16 (1);
  }

  if (VAR_72 > 0) {
    FUNC_34();
  }

  FUNC_38 (VAR_46);

  return 0;
}
