
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_40__ TYPE_6__ ;
typedef struct TYPE_39__ TYPE_5__ ;
typedef struct TYPE_38__ TYPE_4__ ;
typedef struct TYPE_37__ TYPE_3__ ;
typedef struct TYPE_36__ TYPE_2__ ;
typedef struct TYPE_35__ TYPE_1__ ;


typedef int svn_stream_t ;
typedef int svn_ra_svn_conn_t ;
typedef int svn_node_kind_t ;
struct TYPE_35__ {scalar_t__ apr_err; } ;
typedef TYPE_1__ svn_error_t ;
struct TYPE_36__ {int cache_size; void* single_threaded; } ;
typedef TYPE_2__ svn_cache_config_t ;
typedef int svn_boolean_t ;
struct TYPE_37__ {char* root; int tunnel; char const* tunnel_user; int memory_cache_size; int zero_copy_limit; int error_check_interval; int max_request_size; int max_response_size; int * logger; int compression_level; int * config_pool; int * cfg; int * base; int * fs_config; void* vhost; void* read_only; int username_case; } ;
typedef TYPE_3__ serve_params_t ;
typedef enum run_mode { ____Placeholder_run_mode } run_mode ;
typedef enum connection_handling_mode { ____Placeholder_connection_handling_mode } connection_handling_mode ;
struct TYPE_38__ {int pool; } ;
typedef TYPE_4__ connection_t ;
typedef int apr_uint64_t ;
typedef int apr_uint16_t ;
typedef scalar_t__ apr_status_t ;
typedef int apr_socket_t ;
struct TYPE_39__ {int family; } ;
typedef TYPE_5__ apr_sockaddr_t ;
typedef int apr_size_t ;
typedef int apr_proc_t ;
typedef int apr_pool_t ;
typedef int apr_int32_t ;
struct TYPE_40__ {int ind; } ;
typedef TYPE_6__ apr_getopt_t ;


 int VAR_0 ;
 scalar_t__ FUNC_0 (int ) ;
 scalar_t__ VAR_1 ;
 int VAR_2 ;
 int VAR_3 ;
 scalar_t__ VAR_4 ;
 int VAR_5 ;
 int VAR_6 ;
 int VAR_7 ;
 int VAR_8 ;
 int VAR_9 ;
 scalar_t__ FUNC_1 (scalar_t__) ;
 scalar_t__ VAR_10 ;
 int VAR_11 ;
 int VAR_12 ;
 int VAR_13 ;
 int VAR_14 ;
 int VAR_15 ;
 int VAR_16 ;
 void* VAR_17 ;
 int VAR_18 ;
 int VAR_19 ;
 int VAR_20 ;
 int VAR_21 ;
 int VAR_22 ;
 int VAR_23 ;
 int VAR_24 ;
 int VAR_25 ;
 int VAR_26 ;
 int VAR_27 ;
 int FUNC_2 (int ) ;
 int VAR_28 ;
 int VAR_29 ;
 int VAR_30 ;
 int VAR_31 ;
 int VAR_32 ;
 int VAR_33 ;
 int VAR_34 ;
 TYPE_1__* VAR_35 ;
 int VAR_36 ;
 int VAR_37 ;
 int VAR_38 ;
 int VAR_39 ;
 void* VAR_40 ;
 char* FUNC_3 (char*) ;
 int FUNC_4 (TYPE_4__**,int *,TYPE_3__*,int,int *) ;
 scalar_t__ FUNC_5 (TYPE_6__*,int ,int*,char const**) ;
 int * FUNC_6 (int *) ;
 scalar_t__ FUNC_7 (int *,int *) ;
 int VAR_41 ;
 int FUNC_8 (int *,int *,int ,int ) ;
 int FUNC_9 (int ) ;
 scalar_t__ FUNC_10 (int *,int ) ;
 int FUNC_11 (int ,int ) ;
 scalar_t__ FUNC_12 (TYPE_5__**,char const*,int,int ,int ,int *) ;
 scalar_t__ FUNC_13 (int *,TYPE_5__*) ;
 int FUNC_14 (int *) ;
 scalar_t__ FUNC_15 (int **,int ,int ,int ,...) ;
 scalar_t__ FUNC_16 (int *,int ) ;
 scalar_t__ FUNC_17 (int *,int ,int) ;
 int FUNC_18 (char const*,int *,int ) ;
 scalar_t__ FUNC_19 (int **,int,int,int *) ;
 int FUNC_20 (int *,int ) ;
 scalar_t__ FUNC_21 (int *,int ,TYPE_4__*,int ,int *) ;
 int FUNC_22 (int *,int ) ;
 int FUNC_23 (char const*) ;
 int FUNC_24 (TYPE_4__*) ;
 int FUNC_25 () ;
 int FUNC_26 (TYPE_4__*) ;



 int VAR_42 ;
 int FUNC_27 (int *) ;
 int FUNC_28 (int *) ;
 int FUNC_29 (int **,char const*,int *) ;
 int FUNC_30 (int **,int *) ;
 int FUNC_31 (int *,TYPE_1__*,int *,int *) ;
 int VAR_43 ;
 int VAR_44 ;
 int VAR_45 ;
 int VAR_46 ;
 int VAR_47 ;
 int VAR_48 ;
 int VAR_49 ;
 TYPE_1__* FUNC_32 (int *,TYPE_3__*,int *) ;
 TYPE_1__* FUNC_33 (TYPE_4__*,int ) ;
 int VAR_50 ;
 int VAR_51 ;
 int VAR_52 ;
 TYPE_2__* FUNC_34 () ;
 int FUNC_35 (TYPE_2__*) ;
 int FUNC_36 (TYPE_6__**,int,char const**,int *) ;
 TYPE_1__* FUNC_37 (int ,int *,char*) ;
 TYPE_1__* FUNC_38 (char*,char*,int *,...) ;
 int FUNC_39 (int*,char const*) ;
 TYPE_1__* FUNC_40 (int*,char const*,int ,int ,int) ;
 int * FUNC_41 (char const*,int *) ;
 int FUNC_42 (char const**,char const*,int *) ;
 void* FUNC_43 (char const*,int *) ;
 int FUNC_44 (TYPE_1__*) ;
 TYPE_1__* FUNC_45 (int ,int *,char*) ;
 TYPE_1__* FUNC_46 (int ,TYPE_1__*,char*,char const*) ;
 TYPE_1__* FUNC_47 (scalar_t__,char*) ;
 int FUNC_48 (int *) ;
 int FUNC_49 (TYPE_1__*,int ,void*,char*) ;
 int FUNC_50 (int *,int ,char*) ;
 int FUNC_51 (char const*,int *,int *) ;
 int VAR_53 ;
 int * FUNC_52 (int *) ;
 int FUNC_53 (int *) ;
 int * FUNC_54 (int *,int *,int *,int ,int,int,int,int,int *) ;
 int FUNC_55 (int **,int,int *) ;
 int FUNC_56 (int **,int *,char const*,void*,int *,int *) ;
 int FUNC_57 (int *) ;
 int FUNC_58 (int *) ;
 int FUNC_59 (int **,void*,int *) ;
 int FUNC_60 (int **,int *) ;
 int FUNC_61 (char const*) ;
 int VAR_54 ;
 int FUNC_62 (char const**,char const*,int *) ;
 int VAR_55 ;
 int * VAR_56 ;
 int FUNC_63 (char const*,int *) ;
 int FUNC_64 (int,int *) ;
 int FUNC_65 () ;
 TYPE_1__* FUNC_66 () ;
 int VAR_57 ;
 int FUNC_67 (char const*,int *) ;

__attribute__((used)) static svn_error_t *
FUNC_68(int *VAR_58, int VAR_59, const char *VAR_60[], apr_pool_t *VAR_61)
{
  enum run_mode VAR_62 = VAR_49;
  svn_boolean_t VAR_63 = VAR_17;
  apr_socket_t *VAR_64;
  apr_sockaddr_t *VAR_65;
  svn_error_t *VAR_66;
  apr_getopt_t *VAR_67;
  int VAR_68;
  serve_params_t VAR_69;
  const char *VAR_70;
  apr_status_t VAR_71;

  apr_proc_t VAR_72;

  svn_boolean_t VAR_73;
  enum connection_handling_mode VAR_74 = VAR_14;
  svn_boolean_t VAR_75 = VAR_40;
  svn_boolean_t VAR_76 = VAR_40;
  svn_boolean_t VAR_77 = VAR_40;
  svn_boolean_t VAR_78 = VAR_17;
  svn_boolean_t VAR_79 = VAR_17;
  apr_uint16_t VAR_80 = VAR_36;
  const char *VAR_81 = ((void*)0);
  int VAR_82 = VAR_2;
  apr_int32_t VAR_83 = 0;



  svn_boolean_t VAR_84 = VAR_17;
  svn_boolean_t VAR_85 = VAR_17;
  int VAR_86 = 0;
  int VAR_87 = 0;
  const char *VAR_88 = ((void*)0);
  const char *VAR_89 = ((void*)0);
  const char *VAR_90 = ((void*)0);
  svn_node_kind_t VAR_91;
  apr_size_t VAR_92 = VAR_38;
  apr_size_t VAR_93 = VAR_37;





  FUNC_2(FUNC_25());


  FUNC_2(FUNC_48(VAR_61));


  FUNC_2(FUNC_57(VAR_61));

  FUNC_2(FUNC_36(&VAR_67, VAR_59, VAR_60, VAR_61));

  VAR_69.root = "/";
  VAR_69.tunnel = VAR_17;
  VAR_69.tunnel_user = ((void*)0);
  VAR_69.read_only = VAR_17;
  VAR_69.base = ((void*)0);
  VAR_69.cfg = ((void*)0);
  VAR_69.compression_level = VAR_25;
  VAR_69.logger = ((void*)0);
  VAR_69.config_pool = ((void*)0);
  VAR_69.fs_config = ((void*)0);
  VAR_69.vhost = VAR_17;
  VAR_69.username_case = VAR_13;
  VAR_69.memory_cache_size = (apr_uint64_t)-1;
  VAR_69.zero_copy_limit = 0;
  VAR_69.error_check_interval = 4096;
  VAR_69.max_request_size = VAR_19 * 0x100000;
  VAR_69.max_response_size = 0;

  while (1)
    {
      VAR_71 = FUNC_5(VAR_67, VAR_55, &VAR_68, &VAR_70);
      if (FUNC_1(VAR_71))
        break;
      if (VAR_71 != VAR_10)
        {
          FUNC_63(VAR_60[0], VAR_61);
          *VAR_58 = VAR_16;
          return VAR_35;
        }
      switch (VAR_68)
        {
        case '6':




          break;

        case 'h':
          FUNC_28(VAR_61);
          return VAR_35;

        case 'q':
          VAR_84 = VAR_40;
          break;

        case 132:
          VAR_85 = VAR_40;
          break;

        case 'd':
          if (VAR_62 != VAR_44)
            {
              VAR_62 = VAR_44;
              VAR_86++;
            }
          break;

        case 144:
          VAR_63 = VAR_40;
          break;

        case 134:
          VAR_74 = 129;
          VAR_87++;
          break;

        case 'i':
          if (VAR_62 != VAR_45)
            {
              VAR_62 = VAR_45;
              VAR_86++;
            }
          break;

        case 142:
          {
            apr_uint64_t VAR_94;

            VAR_66 = FUNC_40(&VAR_94, VAR_70, 0, VAR_11, 10);
            if (VAR_66)
              return FUNC_46(VAR_28, VAR_66,
                                       FUNC_3("Invalid port '%s'"), VAR_70);
            VAR_80 = (apr_uint16_t)VAR_94;
          }
          break;

        case 143:
          VAR_81 = VAR_70;
          break;

        case 't':
          if (VAR_62 != VAR_48)
            {
              VAR_62 = VAR_48;
              VAR_86++;
            }
          break;

        case 133:
          VAR_69.tunnel_user = VAR_70;
          break;

        case 'X':
          if (VAR_62 != VAR_46)
            {
              VAR_62 = VAR_46;
              VAR_86++;
            }
          break;

        case 'r':
          FUNC_2(FUNC_62(&VAR_69.root, VAR_70, VAR_61));

          FUNC_2(FUNC_51(VAR_69.root, &VAR_91, VAR_61));
          if (VAR_91 != VAR_53)
            {
              return FUNC_46(VAR_29, ((void*)0),
                       FUNC_3("Root path '%s' does not exist "
                         "or is not a directory"), VAR_69.root);
            }

          VAR_69.root = FUNC_43(VAR_69.root, VAR_61);
          FUNC_2(FUNC_42(&VAR_69.root, VAR_69.root, VAR_61));
          break;

        case 'R':
          VAR_69.read_only = VAR_40;
          break;

        case 'T':
          VAR_74 = 128;
          VAR_87++;
          break;

        case 'c':
          VAR_69.compression_level = FUNC_23(VAR_70);
          if (VAR_69.compression_level < VAR_27)
            VAR_69.compression_level = VAR_27;
          if (VAR_69.compression_level > VAR_26)
            VAR_69.compression_level = VAR_26;
          break;

        case 'M':
          {
            apr_uint64_t VAR_95;
            FUNC_2(FUNC_39(&VAR_95, VAR_70));

            VAR_69.memory_cache_size = 0x100000 * VAR_95;
          }
          break;

        case 147:
          VAR_77 = FUNC_61(VAR_70) == VAR_54;
          break;

        case 150:
          VAR_75 = FUNC_61(VAR_70) == VAR_54;
          break;

        case 148:
          VAR_78 = FUNC_61(VAR_70) == VAR_54;
          break;

        case 149:
          VAR_76 = FUNC_61(VAR_70) == VAR_54;
          break;

        case 151:
          VAR_79 = FUNC_61(VAR_70) == VAR_54;
          break;

        case 146:
          {
            apr_size_t VAR_96 = (apr_size_t)FUNC_18(VAR_70, ((void*)0), 0);


            if (VAR_96 >= 1000)
              {


                VAR_69.zero_copy_limit = VAR_96 * 120;


                VAR_69.error_check_interval = VAR_96 * 120;
              }
          }
          break;

        case 140:
          VAR_69.max_request_size = 0x100000 * FUNC_18(VAR_70, ((void*)0), 0);
          break;

        case 139:
          VAR_69.max_response_size = 0x100000 * FUNC_18(VAR_70, ((void*)0), 0);
          break;

        case 137:
          VAR_92 = (apr_size_t)FUNC_18(VAR_70, ((void*)0), 0);
          break;

        case 138:
          VAR_93 = (apr_size_t)FUNC_18(VAR_70, ((void*)0), 0);
          break;
        case 145:
          FUNC_2(FUNC_62(&VAR_88, VAR_70, VAR_61));
          VAR_88 = FUNC_43(VAR_88, VAR_61);
          FUNC_2(FUNC_42(&VAR_88, VAR_88,
                                          VAR_61));
          break;

        case 136:
          FUNC_2(FUNC_62(&VAR_89, VAR_70, VAR_61));
          VAR_89 = FUNC_43(VAR_89, VAR_61);
          FUNC_2(FUNC_42(&VAR_89, VAR_89, VAR_61));
          break;

         case 131:
           VAR_69.vhost = VAR_40;
           break;

         case 141:
          FUNC_2(FUNC_62(&VAR_90, VAR_70, VAR_61));
          VAR_90 = FUNC_43(VAR_90, VAR_61);
          FUNC_2(FUNC_42(&VAR_90, VAR_90, VAR_61));
          break;

        }
    }

  if (VAR_85)
    {
      FUNC_2(FUNC_64(VAR_84, VAR_61));
      return VAR_35;
    }

  if (VAR_67->ind != VAR_59)
    {
      FUNC_63(VAR_60[0], VAR_61);
      *VAR_58 = VAR_16;
      return VAR_35;
    }

  if (VAR_86 != 1)
    {
      FUNC_44(FUNC_38(




                      FUNC_3("You must specify exactly one of -d, -i, -t or -X.\n"),

                       VAR_52, VAR_61));
      FUNC_63(VAR_60[0], VAR_61);
      *VAR_58 = VAR_16;
      return VAR_35;
    }

  if (VAR_87 > 1)
    {
      FUNC_44(FUNC_38(
                      FUNC_3("You may only specify one of -T or --single-thread\n"),
                      VAR_52, VAR_61));
      FUNC_63(VAR_60[0], VAR_61);
      *VAR_58 = VAR_16;
      return VAR_35;
    }


  VAR_73 = VAR_74 == 128;
  VAR_69.fs_config = FUNC_6(VAR_61);
  FUNC_50(VAR_69.fs_config, VAR_31,
                VAR_77 ? "1" :"0");
  FUNC_50(VAR_69.fs_config, VAR_32,
                VAR_75 ? "1" :"0");
  FUNC_50(VAR_69.fs_config, VAR_33,
                VAR_76 ? "1" :"0");
  FUNC_50(VAR_69.fs_config, VAR_34,
                VAR_78 ? "2" :"0");
  FUNC_50(VAR_69.fs_config, VAR_30,
                VAR_79 ? "1" :"0");

  FUNC_2(FUNC_55(&VAR_69.config_pool,
                                        VAR_73,
                                        VAR_61));



  if (VAR_88)
    {
      VAR_69.base = FUNC_41(VAR_88, VAR_61);

      FUNC_2(FUNC_56(&VAR_69.cfg,
                                         VAR_69.config_pool,
                                         VAR_88,
                                         VAR_40,
                                         ((void*)0),
                                         VAR_61));
    }

  if (VAR_90)
    FUNC_2(FUNC_29(&VAR_69.logger, VAR_90, VAR_61));
  else if (VAR_62 == VAR_46)
    FUNC_2(FUNC_30(&VAR_69.logger, VAR_61));

  if (VAR_69.tunnel_user && VAR_62 != VAR_48)
    {
      return FUNC_45(VAR_28, ((void*)0),
               FUNC_3("Option --tunnel-user is only valid in tunnel mode"));
    }

  if (VAR_62 == VAR_45 || VAR_62 == VAR_48)
    {
      apr_pool_t *VAR_97;
      svn_ra_svn_conn_t *VAR_98;
      svn_stream_t *VAR_99;
      svn_stream_t *VAR_100;

      VAR_69.tunnel = (VAR_62 == VAR_48);
      FUNC_8(VAR_61, VAR_61, VAR_41,
                                VAR_43);



      FUNC_2(FUNC_59(&VAR_99, VAR_17, VAR_61));
      FUNC_2(FUNC_60(&VAR_100, VAR_61));




      VAR_97 = FUNC_52(VAR_61);
      VAR_98 = FUNC_54(((void*)0), VAR_99, VAR_100,
                                     VAR_69.compression_level,
                                     VAR_69.zero_copy_limit,
                                     VAR_69.error_check_interval,
                                     VAR_69.max_request_size,
                                     VAR_69.max_response_size,
                                     VAR_97);
      VAR_66 = FUNC_32(VAR_98, &VAR_69, VAR_97);
      FUNC_53(VAR_97);

      return VAR_66;
    }
  VAR_71 = FUNC_12(&VAR_65, VAR_81, VAR_82, VAR_80,
                                 VAR_83, VAR_61);
  if (VAR_71)
    {
      return FUNC_47(VAR_71, FUNC_3("Can't get address info"));
    }






  VAR_71 = FUNC_15(&VAR_64, VAR_65->family, VAR_24, VAR_8,
                             VAR_61);

  if (VAR_71)
    {
      return FUNC_47(VAR_71, FUNC_3("Can't create server socket"));
    }



  VAR_71 = FUNC_17(VAR_64, VAR_9, 1);
  if (VAR_71)
    {
      return FUNC_47(VAR_71, FUNC_3("Can't set options on server socket"));
    }

  VAR_71 = FUNC_13(VAR_64, VAR_65);
  if (VAR_71)
    {
      return FUNC_47(VAR_71, FUNC_3("Can't bind server socket"));
    }

  VAR_71 = FUNC_16(VAR_64, VAR_0);
  if (VAR_71)
    {
      return FUNC_47(VAR_71, FUNC_3("Can't listen on server socket"));
    }
  if (VAR_89)
    FUNC_2(FUNC_67(VAR_89, VAR_61));
  {
    svn_cache_config_t VAR_101 = *FUNC_34();

    if (VAR_69.memory_cache_size != -1)
      VAR_101.cache_size = VAR_69.memory_cache_size;

    VAR_101.single_threaded = VAR_40;
    if (VAR_74 == 128)
      {
      }

    FUNC_35(&VAR_101);
  }
  while (1)
    {
      connection_t *VAR_102 = ((void*)0);
      FUNC_2(FUNC_4(&VAR_102, VAR_64, &VAR_69, VAR_74,
                                VAR_61));
      if (VAR_62 == VAR_46)
        {
          VAR_66 = FUNC_33(VAR_102, VAR_102->pool);
          FUNC_26(VAR_102);
          return VAR_66;
        }

      switch (VAR_74)
        {
        case 130:
          break;

        case 128:
          break;

        case 129:


          FUNC_44(FUNC_33(VAR_102, VAR_102->pool));
        }

      FUNC_26(VAR_102);
    }


}
