
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_30__ TYPE_9__ ;
typedef struct TYPE_29__ TYPE_8__ ;
typedef struct TYPE_28__ TYPE_7__ ;
typedef struct TYPE_27__ TYPE_6__ ;
typedef struct TYPE_26__ TYPE_4__ ;
typedef struct TYPE_25__ TYPE_3__ ;
typedef struct TYPE_24__ TYPE_2__ ;
typedef struct TYPE_23__ TYPE_1__ ;
typedef struct TYPE_22__ TYPE_12__ ;
typedef struct TYPE_21__ TYPE_10__ ;


struct mips_hi_fixup {int seg; TYPE_12__* fixp; struct mips_hi_fixup* next; } ;
struct mips_cl_insn {int mips16_absolute_jump_p; int fixed_p; unsigned int insn_opcode; scalar_t__ where; TYPE_7__* frag; TYPE_12__** fixp; scalar_t__ noreorder_p; int use_extend; TYPE_1__* insn_mo; } ;
struct TYPE_24__ {int * label_list; } ;
typedef TYPE_2__ segment_info_type ;
struct TYPE_25__ {int partial_inplace; } ;
typedef TYPE_3__ reloc_howto_type ;
typedef scalar_t__ relax_stateT ;
typedef int fragS ;
struct TYPE_26__ {unsigned int X_add_number; scalar_t__ X_op; int X_add_symbol; } ;
typedef TYPE_4__ expressionS ;
typedef int bfd_reloc_code_real_type ;
typedef scalar_t__ bfd_boolean ;
struct TYPE_30__ {scalar_t__ nomove; scalar_t__ mips16; scalar_t__ noreorder; scalar_t__ noat; int warn_about_macros; } ;
struct TYPE_29__ {int sequence; int* sizes; TYPE_12__* first_fixup; } ;
struct TYPE_28__ {scalar_t__ fr_type; int fr_fix; } ;
struct TYPE_27__ {int fr_fix; } ;
struct TYPE_23__ {unsigned long pinfo; } ;
struct TYPE_22__ {int fx_no_overflow; int fx_tcbit; int fx_size; scalar_t__ fx_addsy; } ;
struct TYPE_21__ {int* sizes; } ;


 int VAR_0 ;


 int VAR_1 ;
 int VAR_2 ;
 int VAR_3 ;
 int VAR_4 ;



 int VAR_5 ;
 int VAR_6 ;

 int VAR_7 ;




 int VAR_8 ;
 int VAR_9 ;
 int VAR_10 ;
 int VAR_11 ;
 int VAR_12 ;

 scalar_t__ VAR_13 ;
 int FUNC_0 (int ,struct mips_cl_insn) ;
 scalar_t__ VAR_14 ;
 int VAR_15 ;
 int VAR_16 ;
 int VAR_17 ;
 int VAR_18 ;
 scalar_t__ VAR_19 ;
 unsigned long VAR_20 ;
 unsigned long VAR_21 ;
 unsigned long VAR_22 ;
 unsigned long VAR_23 ;
 unsigned long VAR_24 ;
 unsigned long VAR_25 ;
 unsigned long VAR_26 ;
 unsigned long VAR_27 ;
 unsigned long VAR_28 ;
 unsigned long VAR_29 ;
 unsigned long VAR_30 ;
 unsigned long VAR_31 ;
 unsigned long VAR_32 ;
 unsigned long VAR_33 ;
 unsigned long VAR_34 ;
 unsigned long VAR_35 ;
 unsigned long VAR_36 ;
 unsigned long VAR_37 ;
 unsigned long VAR_38 ;
 scalar_t__ VAR_39 ;
 int FUNC_1 (int) ;
 int FUNC_2 (int ,struct mips_cl_insn) ;
 unsigned long VAR_40 ;
 unsigned long VAR_41 ;
 unsigned long VAR_42 ;
 unsigned long VAR_43 ;
 unsigned long VAR_44 ;
 unsigned long VAR_45 ;
 unsigned long VAR_46 ;
 unsigned long VAR_47 ;
 unsigned long VAR_48 ;
 unsigned long VAR_49 ;
 unsigned long VAR_50 ;
 unsigned long VAR_51 ;
 unsigned long VAR_52 ;
 unsigned long VAR_53 ;
 unsigned long VAR_54 ;
 int VAR_55 ;
 int VAR_56 ;
 int VAR_57 ;
 struct mips_cl_insn* VAR_58 ;
 scalar_t__ VAR_59 ;
 scalar_t__ VAR_60 ;
 int VAR_61 ;
 int VAR_62 ;
 int VAR_63 ;
 int FUNC_3 (unsigned long,unsigned long,unsigned long,int ) ;
 int FUNC_4 (int,int ,int ,unsigned long,int) ;
 int VAR_64 ;
 int VAR_65 ;
 int VAR_66 ;
 int VAR_67 ;
 int VAR_68 ;
 int VAR_69 ;
 int VAR_70 ;
 scalar_t__ VAR_71 ;
 int FUNC_5 (char*) ;
 int FUNC_6 (struct mips_cl_insn*) ;
 int FUNC_7 (struct mips_cl_insn*,int,int,int ,int ,unsigned int) ;
 int FUNC_8 (int ,unsigned long) ;
 int FUNC_9 (int ) ;
 int FUNC_10 (int) ;
 int FUNC_11 (TYPE_3__*) ;
 TYPE_3__* FUNC_12 (int ,int) ;
 int FUNC_13 (int) ;
 int FUNC_14 (int *,unsigned long) ;
 int FUNC_15 () ;
 TYPE_12__* FUNC_16 (TYPE_7__*,scalar_t__,int ,int *,int ,scalar_t__,int) ;
 TYPE_12__* FUNC_17 (TYPE_7__*,scalar_t__,int ,TYPE_4__*,int,int) ;
 int FUNC_18 (TYPE_12__*) ;
 int FUNC_19 (int) ;
 int * VAR_72 ;
 unsigned long FUNC_20 () ;
 int FUNC_21 () ;
 struct mips_cl_insn* VAR_73 ;
 int FUNC_22 (int ,int,struct mips_cl_insn*) ;
 scalar_t__ FUNC_23 (struct mips_cl_insn*) ;
 scalar_t__ FUNC_24 (struct mips_cl_insn*,int,int ) ;
 int FUNC_25 (struct mips_cl_insn*) ;
 int FUNC_26 () ;
 int FUNC_27 (int) ;
 scalar_t__ VAR_74 ;
 int FUNC_28 () ;
 int FUNC_29 (TYPE_4__*) ;
 int VAR_75 ;
 int FUNC_30 () ;
 int VAR_76 ;
 int FUNC_31 () ;
 int* VAR_77 ;
 int VAR_78 ;
 struct mips_hi_fixup* VAR_79 ;
 TYPE_10__ VAR_80 ;
 int FUNC_32 () ;
 int FUNC_33 () ;
 int VAR_81 ;
 TYPE_9__ VAR_82 ;
 scalar_t__ VAR_83 ;
 TYPE_8__ VAR_84 ;
 scalar_t__ VAR_85 ;
 int FUNC_34 (struct mips_cl_insn*,TYPE_7__*,scalar_t__) ;
 scalar_t__ FUNC_35 (struct mips_cl_insn*,struct mips_cl_insn*) ;
 scalar_t__ FUNC_36 (struct mips_cl_insn*,struct mips_cl_insn*) ;
 scalar_t__ FUNC_37 (int,struct mips_cl_insn*,struct mips_cl_insn*,struct mips_cl_insn*) ;
 int VAR_86 ;
 TYPE_6__* VAR_87 ;
 int VAR_88 ;
 int VAR_89 ;
 int VAR_90 ;
 int FUNC_38 () ;
 int FUNC_39 (int *,int *,int) ;
 scalar_t__ FUNC_40 (int) ;
 scalar_t__ VAR_91 ;
 TYPE_2__* FUNC_41 (int ) ;
 int VAR_92 ;
 int* FUNC_42 (scalar_t__) ;
 scalar_t__ FUNC_43 (int) ;

__attribute__((used)) static void
FUNC_44 (struct mips_cl_insn *VAR_93, expressionS *VAR_94,
      bfd_reloc_code_real_type *VAR_95)
{
  unsigned long VAR_96, VAR_97;
  relax_stateT VAR_98 = 0;
  bfd_boolean VAR_99 = VAR_14;
  segment_info_type *VAR_100 = FUNC_41 (VAR_86);


  FUNC_30 ();

  VAR_96 = VAR_73[0].insn_mo->pinfo;
  VAR_97 = VAR_93->insn_mo->pinfo;

  if (VAR_84.sequence != 2 && !VAR_82.noreorder)
    {







      int VAR_101 = (VAR_81 == 0
    ? FUNC_35 (VAR_73, ((void*)0))
    : FUNC_36 (VAR_73, VAR_93));
      if (VAR_101 > 0)
 {
   fragS *VAR_102;
   unsigned long VAR_103;
   int VAR_104;

   VAR_102 = VAR_72;
   VAR_103 = FUNC_20 ();

   for (VAR_104 = 0; VAR_104 < VAR_101; VAR_104++)
     FUNC_15 ();

   if (VAR_74)
     {
       FUNC_28 ();
       FUNC_19 (40);
     }

   FUNC_32 ();


   if (VAR_13)
     FUNC_14 (VAR_102, VAR_103);

 }
    }
  else if (VAR_84.sequence != 2 && VAR_87 != ((void*)0))
    {

      int VAR_105 = FUNC_36 (VAR_73, VAR_93);
      FUNC_10 (VAR_105 <= VAR_88);


      if (VAR_105 > VAR_89)
 VAR_89 = VAR_105;

      if (VAR_88 == VAR_89)
 {


   VAR_87 = ((void*)0);
   FUNC_22 (VAR_90,
          VAR_88, VAR_58);
 }
      else
 {


   VAR_87->fr_fix -= VAR_82.mips16 ? 2 : 4;
   VAR_88--;
   VAR_90++;
 }
    }
  if (VAR_73[0].frag)
    VAR_98 = VAR_73[0].frag->fr_type;

  if (VAR_94
      && *VAR_95 == 138
      && (VAR_97 & VAR_31 || VAR_97 & VAR_20
   || VAR_97 & VAR_21)
      && VAR_85



      && !VAR_82.warn_about_macros
      && !(VAR_82.noat && VAR_83 != VAR_59)
      && !VAR_82.mips16)
    {
      VAR_99 = VAR_71;
      FUNC_7 (VAR_93, (FUNC_39
        (((void*)0), ((void*)0),
         (VAR_97 & VAR_31) ? -1
         : (VAR_97 & VAR_21) ? 1
         : 0)), 4,
   FUNC_3
   (VAR_97 & VAR_31,
    VAR_97 & VAR_21,
    VAR_97 & VAR_36,
    0),
   VAR_94->X_add_symbol,
   VAR_94->X_add_number);
      *VAR_95 = 128;
    }
  else if (*VAR_95 > 128)
    {

      FUNC_10 (VAR_82.mips16 && VAR_94 != ((void*)0));
      FUNC_7 (VAR_93, 4, 0,
   FUNC_4
   (*VAR_95 - 128,
    VAR_76, VAR_75,
    VAR_96 & VAR_31,
    VAR_73[0].mips16_absolute_jump_p),
   FUNC_29 (VAR_94), 0);
    }
  else if (VAR_82.mips16
    && ! VAR_93->use_extend
    && *VAR_95 != 133)
    {
      if ((VAR_97 & VAR_31) == 0)


 FUNC_19 (6);
      FUNC_6 (VAR_93);
    }
  else
    {
      if (VAR_82.mips16
   && VAR_82.noreorder
   && (VAR_96 & VAR_31) != 0)
 FUNC_9 (FUNC_5("extended instruction in delay slot"));

      if (VAR_84.sequence)
 {



   if (FUNC_21 () < 4)
     FUNC_38 ();
   VAR_84.sizes[VAR_84.sequence - 1] += 4;
 }

      if (VAR_84.sequence != 2)
 VAR_80.sizes[0] += 4;
      if (VAR_84.sequence != 1)
 VAR_80.sizes[1] += 4;

      if (VAR_82.mips16)
 {
   VAR_93->fixed_p = 1;
   VAR_93->mips16_absolute_jump_p = (*VAR_95 == 133);
 }
      FUNC_6 (VAR_93);
    }

  if (VAR_94 != ((void*)0) && *VAR_95 <= 128)
    {
      if (VAR_94->X_op == VAR_60)
 {
   unsigned int VAR_106;

   switch (*VAR_95)
     {
     case 137:
       VAR_93->insn_opcode |= VAR_94->X_add_number;
       break;

     case 130:
       VAR_106 = (VAR_94->X_add_number + 0x800080008000ull) >> 48;
       VAR_93->insn_opcode |= VAR_106 & 0xffff;
       break;

     case 131:
       VAR_106 = (VAR_94->X_add_number + 0x80008000ull) >> 32;
       VAR_93->insn_opcode |= VAR_106 & 0xffff;
       break;

     case 135:
       VAR_106 = (VAR_94->X_add_number + 0x8000) >> 16;
       VAR_93->insn_opcode |= VAR_106 & 0xffff;
       break;

     case 136:
       VAR_93->insn_opcode |= (VAR_94->X_add_number >> 16) & 0xffff;
       break;

     case 128:
     case 134:
     case 132:
       VAR_93->insn_opcode |= VAR_94->X_add_number & 0xffff;
       break;

     case 129:
       if ((VAR_94->X_add_number & 3) != 0)
  FUNC_8 (FUNC_5("jump to misaligned address (0x%lx)"),
   (unsigned long) VAR_94->X_add_number);
       VAR_93->insn_opcode |= (VAR_94->X_add_number >> 2) & 0x3ffffff;
       break;

     case 133:
       if ((VAR_94->X_add_number & 3) != 0)
  FUNC_8 (FUNC_5("jump to misaligned address (0x%lx)"),
   (unsigned long) VAR_94->X_add_number);
       VAR_93->insn_opcode |=
  (((VAR_94->X_add_number & 0x7c0000) << 3)
   | ((VAR_94->X_add_number & 0xf800000) >> 7)
   | ((VAR_94->X_add_number & 0x3fffc) >> 2));
       break;

     case 138:
       if ((VAR_94->X_add_number & 3) != 0)
  FUNC_8 (FUNC_5("branch to misaligned address (0x%lx)"),
   (unsigned long) VAR_94->X_add_number);
       if (VAR_85)
  goto need_reloc;
       if ((VAR_94->X_add_number + 0x20000) & ~0x3ffff)
  FUNC_8 (FUNC_5("branch address range overflow (0x%lx)"),
   (unsigned long) VAR_94->X_add_number);
       VAR_93->insn_opcode |= (VAR_94->X_add_number >> 2) & 0xffff;
       break;

     default:
       FUNC_26 ();
     }
 }
      else if (*VAR_95 < 128)
 need_reloc:
 {
   reloc_howto_type *VAR_107;
   int VAR_108;



   for (VAR_108 = 1; VAR_108 < 3; VAR_108++)
     if (VAR_95[VAR_108] == 128)
       break;

   VAR_107 = FUNC_12 (VAR_92, VAR_95[VAR_108 - 1]);
   VAR_93->fixp[0] = FUNC_17 (VAR_93->frag, VAR_93->where,
         FUNC_11 (VAR_107),
         VAR_94,
         VAR_95[0] == 138,
         VAR_95[0]);


   if (VAR_95[0] == 133
       && VAR_93->fixp[0]->fx_addsy)
     *FUNC_42 (VAR_93->fixp[0]->fx_addsy) = 1;



   if (VAR_19
       && ! VAR_107->partial_inplace
       && (VAR_95[0] == VAR_0
    || VAR_95[0] == 137
    || VAR_95[0] == 129
    || VAR_95[0] == 135
    || VAR_95[0] == 134
    || VAR_95[0] == VAR_3
    || VAR_95[0] == VAR_8
    || VAR_95[0] == VAR_4
    || VAR_95[0] == VAR_1
    || VAR_95[0] == VAR_2
    || VAR_95[0] == VAR_12
    || VAR_95[0] == 130
    || VAR_95[0] == 131
    || VAR_95[0] == VAR_11
    || VAR_95[0] == VAR_9
    || VAR_95[0] == VAR_10
    || VAR_95[0] == VAR_5
    || VAR_95[0] == VAR_6
    || VAR_95[0] == VAR_7))
     VAR_93->fixp[0]->fx_no_overflow = 1;

   if (VAR_84.sequence)
     {
       if (VAR_84.first_fixup == 0)
  VAR_84.first_fixup = VAR_93->fixp[0];
     }
   else if (FUNC_40 (*VAR_95))
     {
       struct mips_hi_fixup *VAR_109;


       VAR_109 = VAR_79;
       if (VAR_109 == 0
    || !FUNC_18 (VAR_109->fixp))
  {
    VAR_109 = ((struct mips_hi_fixup *)
         FUNC_43 (sizeof (struct mips_hi_fixup)));
    VAR_109->next = VAR_79;
    VAR_79 = VAR_109;
  }
       VAR_109->fixp = VAR_93->fixp[0];
       VAR_109->seg = VAR_86;
     }






   for (VAR_108 = 1; VAR_108 < 3; VAR_108++)
     if (VAR_95[VAR_108] != 128)
       {
  VAR_93->fixp[VAR_108] = FUNC_16 (VAR_93->frag, VAR_93->where,
           VAR_93->fixp[0]->fx_size, ((void*)0), 0,
           VAR_14, VAR_95[VAR_108]);


  VAR_93->fixp[0]->fx_tcbit = 1;
  VAR_93->fixp[VAR_108]->fx_tcbit = 1;
       }
 }
    }
  FUNC_25 (VAR_93);


  if (! VAR_82.mips16)
    {
      if (VAR_97 & VAR_37)
 VAR_78 |= 1 << FUNC_0 (VAR_62, *VAR_93);
      if ((VAR_97 & (VAR_38 | VAR_28)) != 0)
 VAR_78 |= 1 << FUNC_0 (VAR_65, *VAR_93);
      if (VAR_97 & VAR_27)
 VAR_78 |= 1 << FUNC_0 (VAR_64, *VAR_93);
      if (VAR_97 & VAR_36)
 VAR_78 |= 1 << VAR_61;
      if (VAR_97 & VAR_33)
 VAR_77[1] |= 1 << FUNC_0 (VAR_15, *VAR_93);
      if ((VAR_97 & (VAR_34 | VAR_25)) != 0)
 VAR_77[1] |= 1 << FUNC_0 (VAR_17, *VAR_93);
      if ((VAR_97 & (VAR_35 | VAR_26)) != 0)
 VAR_77[1] |= 1 << FUNC_0 (VAR_18, *VAR_93);
      if ((VAR_97 & VAR_24) != 0)
 VAR_77[1] |= 1 << FUNC_0 (VAR_16, *VAR_93);
      if (VAR_97 & VAR_22)
 {




 }

      VAR_78 &= ~(1 << 0);
    }
  else
    {
      if (VAR_97 & (VAR_52 | VAR_45))
 VAR_78 |= 1 << FUNC_2 (VAR_66, *VAR_93);
      if (VAR_97 & (VAR_53 | VAR_46))
 VAR_78 |= 1 << FUNC_2 (VAR_67, *VAR_93);
      if (VAR_97 & VAR_54)
 VAR_78 |= 1 << FUNC_2 (VAR_68, *VAR_93);
      if (VAR_97 & (VAR_51 | VAR_44))
 VAR_78 |= 1 << VAR_70;
      if (VAR_97 & (VAR_50 | VAR_43))
 VAR_78 |= 1 << VAR_69;
      if (VAR_97 & (VAR_48 | VAR_40))
 VAR_78 |= 1 << VAR_61;
      if (VAR_97 & VAR_49)
 VAR_78 |= 1 << FUNC_1 (VAR_93->insn_opcode);
      if (VAR_97 & VAR_47)
 VAR_78 |= 1 << FUNC_2 (VAR_57, *VAR_93);
      if (VAR_97 & VAR_41)
 VAR_78 |= 1 << FUNC_2 (VAR_63, *VAR_93);
    }

  if (VAR_84.sequence != 2 && !VAR_82.noreorder)
    {





      if ((VAR_97 & VAR_31)
   || (VAR_97 & VAR_20))
 {
   if (VAR_81 < 2


       || VAR_82.nomove != 0


       || VAR_73[0].fixed_p
       || VAR_73[1].noreorder_p





       || VAR_100->label_list != ((void*)0)




       || (! VAR_82.mips16
    && VAR_98 == VAR_91)


       || FUNC_35 (VAR_73 + 1, VAR_93) > 0


       || FUNC_37 (2, VAR_73 + 1, VAR_93, VAR_73) > 0



       || (VAR_96 & VAR_30)


       || (! VAR_82.mips16
    && (VAR_96 & VAR_38)
    && FUNC_24 (VAR_93, FUNC_0 (VAR_65, VAR_73[0]),
        VAR_56))
       || (! VAR_82.mips16
    && (VAR_96 & VAR_37)
    && FUNC_24 (VAR_93, FUNC_0 (VAR_62, VAR_73[0]),
        VAR_56))
       || (VAR_82.mips16
    && (((VAR_96 & VAR_52)
         && (FUNC_24
      (VAR_93, FUNC_2 (VAR_66, VAR_73[0]),
       VAR_55)))
        || ((VAR_96 & VAR_53)
     && (FUNC_24
         (VAR_93, FUNC_2 (VAR_67, VAR_73[0]),
          VAR_55)))
        || ((VAR_96 & VAR_54)
     && (FUNC_24
         (VAR_93, FUNC_2 (VAR_68, VAR_73[0]),
          VAR_55)))
        || ((VAR_96 & VAR_51)
     && FUNC_24 (VAR_93, VAR_70, VAR_56))
        || ((VAR_96 & VAR_48)
     && FUNC_24 (VAR_93, VAR_61, VAR_56))
        || ((VAR_96 & VAR_49)
     && FUNC_24 (VAR_93,
         FUNC_1
           (VAR_73[0].insn_opcode),
         VAR_56))))



       || (! VAR_82.mips16
    && (VAR_96 & VAR_38)
    && (((VAR_97 & VAR_37)
         && (FUNC_0 (VAR_65, VAR_73[0])
      == FUNC_0 (VAR_62, *VAR_93)))
        || ((VAR_97 & VAR_36)
     && FUNC_0 (VAR_65, VAR_73[0]) == VAR_61)))
       || (! VAR_82.mips16
    && (VAR_96 & VAR_37)
    && (((VAR_97 & VAR_37)
         && (FUNC_0 (VAR_62, VAR_73[0])
      == FUNC_0 (VAR_62, *VAR_93)))
        || ((VAR_97 & VAR_36)
     && FUNC_0 (VAR_62, VAR_73[0]) == VAR_61)))
       || (VAR_82.mips16
    && (VAR_97 & VAR_48)
    && ((VAR_96 & VAR_48)
        || ((VAR_96 & VAR_49)
     && (FUNC_1 (VAR_73[0].insn_opcode)
         == VAR_61))))



       || (! VAR_82.mips16
    && (VAR_97 & VAR_37)
    && FUNC_24 (&VAR_73[0],
        FUNC_0 (VAR_62, *VAR_93),
        VAR_56))
       || (! VAR_82.mips16
    && (VAR_97 & VAR_36)
    && FUNC_24 (&VAR_73[0], VAR_61, VAR_56))
       || (VAR_82.mips16
    && (VAR_97 & VAR_48)
    && FUNC_24 (&VAR_73[0], VAR_61, VAR_56))


       || ((VAR_97 & VAR_23)
    && (VAR_96 & VAR_32))
       || ((VAR_97 & VAR_32)
    && (VAR_96 & VAR_23))


       || (VAR_82.mips16
    && (VAR_96 & VAR_42))



       || (VAR_82.mips16 && VAR_73[0].fixp[0])


       || (VAR_96 & VAR_29))
     {
       if (VAR_82.mips16
    && (VAR_97 & VAR_31)
    && (VAR_97 & (VAR_45 | VAR_40))
    && VAR_39)
  {

    VAR_93->insn_opcode |= 0x0080;
    FUNC_25 (VAR_93);
    FUNC_22 (0, 1, VAR_93);
  }
       else
  {




    FUNC_22 (0, 1, VAR_93);
    FUNC_15 ();
  }

       if (VAR_84.sequence)
  VAR_84.sizes[VAR_84.sequence - 1] += 4;
     }
   else
     {

       struct mips_cl_insn VAR_110 = VAR_73[0];
       if (VAR_82.mips16)
  {
    FUNC_27 (VAR_110.frag == VAR_93->frag);
                  FUNC_34 (VAR_93, VAR_110.frag, VAR_110.where);
    FUNC_34 (&VAR_110, VAR_93->frag, VAR_93->where + FUNC_23 (VAR_93));
  }
       else if (VAR_99)
  {




    VAR_110.frag->fr_fix -= 4;
    if (VAR_110.frag == VAR_93->frag)
      FUNC_34 (VAR_93, VAR_93->frag, VAR_93->where - 4);
    FUNC_6 (&VAR_110);
  }
       else
  {
    FUNC_34 (&VAR_110, VAR_93->frag, VAR_93->where);
    FUNC_34 (VAR_93, VAR_73[0].frag, VAR_73[0].where);
  }
       VAR_73[0] = *VAR_93;
       VAR_110.fixed_p = 1;
       FUNC_22 (0, 1, &VAR_110);
     }



   if (VAR_97 & VAR_31)
     FUNC_33 ();
 }
      else if (VAR_97 & VAR_21)
 {




   FUNC_22 (0, 1, VAR_93);
   FUNC_15 ();
 }
      else
 FUNC_22 (0, 1, VAR_93);
    }
  else
    FUNC_22 (0, 1, VAR_93);


  FUNC_31 ();
}
