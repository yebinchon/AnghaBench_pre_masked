
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_6__ TYPE_2__ ;
typedef struct TYPE_5__ TYPE_1__ ;


typedef union dinode {int dummy; } dinode ;
typedef int time_t ;
struct stat {int st_mode; int st_mtime; } ;
struct fstab {char* fs_spec; char* fs_file; } ;
typedef int intmax_t ;
typedef int ino_t ;
struct TYPE_6__ {int fs_fsize; int fs_ipg; int fs_ncg; } ;
struct TYPE_5__ {scalar_t__ c_date; scalar_t__ c_ddate; char* c_dev; char* c_filesys; int c_level; int c_tapea; int c_volume; int c_type; int c_host; int c_label; } ;


 int VAR_0 ;
 int VAR_1 ;
 int VAR_2 ;

 int FUNC_0 (int ) ;
 double VAR_3 ;
 int VAR_4 ;
 int VAR_5 ;
 int VAR_6 ;
 int VAR_7 ;
 int VAR_8 ;
 int VAR_9 ;
 int VAR_10 ;
 int VAR_11 ;
 int VAR_12 ;
 int VAR_13 ;
 int VAR_14 ;
 scalar_t__ VAR_15 ;
 int VAR_16 ;
 scalar_t__ FUNC_1 (int ) ;
 int VAR_17 ;
 int VAR_18 ;
 int VAR_19 ;
 int VAR_20 ;
 int VAR_21 ;
 int VAR_22 ;
 char* VAR_23 ;
 int VAR_24 ;
 char* VAR_25 ;
 char* VAR_26 ;
 int FUNC_2 (scalar_t__) ;
 void* FUNC_3 (int ) ;
 int FUNC_4 () ;
 int VAR_27 ;
 int FUNC_5 (char*) ;
 int VAR_28 ;
 scalar_t__ FUNC_6 (unsigned int,int) ;
 int VAR_29 ;
 char* FUNC_7 (int *) ;
 int VAR_30 ;
 int VAR_31 ;
 int VAR_32 ;
 char* VAR_33 ;
 int VAR_34 ;
 int FUNC_8 () ;
 char* VAR_35 ;
 char* VAR_36 ;
 int FUNC_9 (union dinode*,int) ;
 char* VAR_37 ;
 int FUNC_10 (char*,int ,int) ;
 int FUNC_11 (int ,char*,char*) ;
 int VAR_38 ;
 int FUNC_12 (int ,char*,...) ;
 int VAR_39 ;
 int FUNC_13 (int ) ;
 int FUNC_14 (int) ;
 int FUNC_15 (int ,char*,...) ;
 int FUNC_16 (TYPE_2__*,int) ;
 struct fstab* FUNC_17 (char*) ;
 scalar_t__ FUNC_18 (int ,struct stat*) ;
 int FUNC_19 () ;
 char* FUNC_20 (char*) ;
 int FUNC_21 (int ,int) ;
 union dinode* FUNC_22 (int,int*) ;
 char* FUNC_23 (char*,int*) ;
 int FUNC_24 (int,char**,char*) ;
 int FUNC_25 () ;
 char* VAR_40 ;
 int FUNC_26 (int,int) ;
 scalar_t__ VAR_41 ;
 int FUNC_27 (int) ;
 int VAR_42 ;
 int VAR_43 ;
 int FUNC_28 (int,int*) ;
 int FUNC_29 (int,int*) ;
 int VAR_44 ;
 int FUNC_30 (char*,...) ;
 int FUNC_31 (char*,char*,...) ;
 int VAR_45 ;
 int VAR_46 ;
 double VAR_47 ;
 int FUNC_32 (char*,long,long) ;
 int FUNC_33 (int*,char***) ;
 int FUNC_34 (char*,int ) ;
 char* VAR_48 ;
 scalar_t__ VAR_49 ;
 int VAR_50 ;
 scalar_t__ VAR_51 ;
 char* VAR_52 ;
 int FUNC_35 () ;
 int FUNC_36 (char*,...) ;
 char* FUNC_37 (char*) ;
 scalar_t__ FUNC_38 (char*) ;
 int FUNC_39 (int,double) ;
 int FUNC_40 (int,int) ;
 int VAR_53 ;
 int FUNC_41 (int ,TYPE_2__**,int ) ;
 TYPE_2__* VAR_54 ;
 int FUNC_42 (char*,char*) ;
 int FUNC_43 (int ) ;
 scalar_t__ VAR_55 ;
 scalar_t__ FUNC_44 (int ,scalar_t__) ;
 scalar_t__ VAR_56 ;
 int FUNC_45 (char*,int,char*,char*,...) ;
 TYPE_1__ VAR_57 ;
 int FUNC_46 (int) ;
 scalar_t__ FUNC_47 (char*,struct stat*) ;
 int VAR_58 ;
 char* FUNC_48 (char*,char) ;
 scalar_t__ FUNC_49 (char*,char*) ;
 int FUNC_50 (int ,char*) ;
 int FUNC_51 (int ) ;
 int FUNC_52 (char*,char*,int) ;
 int FUNC_53 () ;
 scalar_t__ FUNC_54 (char*) ;
 char* VAR_59 ;
 int VAR_60 ;
 int VAR_61 ;
 scalar_t__ VAR_62 ;
 int FUNC_55 (int *) ;
 int VAR_63 ;
 int FUNC_56 () ;
 double VAR_64 ;
 scalar_t__ VAR_65 ;
 int VAR_66 ;
 scalar_t__ FUNC_57 (char*) ;
 int VAR_67 ;
 int FUNC_58 (char*) ;
 int FUNC_59 () ;
 char* VAR_68 ;
 int FUNC_60 (char*) ;
 int FUNC_61 (int) ;

int
FUNC_62(int VAR_69, char *VAR_70[])
{
 struct stat VAR_71;
 ino_t VAR_72;
 int VAR_73;
 union dinode *VAR_74;
 struct fstab *VAR_75;
 char *VAR_76, *VAR_77;
 int VAR_78, VAR_79, VAR_80;
 int VAR_81, VAR_82, VAR_83, VAR_84 = 0, VAR_85 = 0, VAR_86 = 1;
 int VAR_87 = 0;
 ino_t VAR_88;
 char *VAR_89;

 VAR_57.c_date = FUNC_3(FUNC_55(((void*)0)));

 VAR_64 = 0;
 VAR_35 = VAR_25;
 VAR_52 = ((void*)0);
 VAR_59 = ((void*)0);
 VAR_61 = VAR_24;
 if (VAR_17 / VAR_2 == 0 || VAR_17 % VAR_2 != 0)
  FUNC_36("TP_BSIZE must be a multiple of DEV_BSIZE\n");
 VAR_43 = 0;
 VAR_53 = 0;

 if (VAR_69 < 2)
  FUNC_59();

 FUNC_33(&VAR_69, &VAR_70);
 while ((VAR_78 = FUNC_24(VAR_69, VAR_70,
     "0123456789aB:b:C:cD:d:f:h:LnP:RrSs:T:uWw")) != -1)
  switch (VAR_78) {

  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
   VAR_43 = 10 * VAR_43 + VAR_78 - '0';
   break;

  case 'a':
   VAR_67 = 1;
   break;

  case 'B':
   VAR_27 = FUNC_32("number of blocks per file",
       1L, 0L);
   break;

  case 'b':
   VAR_47 = FUNC_32("number of blocks per write",
       1L, 1000L);
   break;

  case 'C':
   VAR_28 = FUNC_32("cachesize", 0, 0) * 1024 * 1024;
   break;

  case 'c':
   VAR_29 = 1;
   break;

  case 'D':
   VAR_35 = VAR_48;
   break;

  case 'd':
   VAR_30 = FUNC_32("density", 10L, 327670L) / 10;
   if (VAR_30 >= 625 && !VAR_84)
    VAR_47 = VAR_3;
   break;

  case 'f':
   if (VAR_52 != ((void*)0))
    FUNC_12(VAR_22, "You cannot use the P and f "
        "flags together.\n");
   VAR_59 = VAR_48;
   break;

  case 'h':
   VAR_86 = FUNC_32("honor level", 0L, 10L);
   break;

  case 'L':
   VAR_56 = 1;
   break;

  case 'n':
   VAR_46 = 1;
   break;

  case 'P':
   if (VAR_59 != ((void*)0))
    FUNC_12(VAR_22, "You cannot use the P and f "
        "flags together.\n");
   VAR_52 = VAR_48;
   break;

  case 'r':
   if (VAR_53 < 1)
    VAR_53 = 1;
   break;

  case 'R':
   if (VAR_53 < 2)
    VAR_53 = 2;
   break;

  case 'S':
   VAR_87 = 1;
   break;

  case 's':
   VAR_64 = FUNC_32("tape size", 1L, 0L) * 12 * 10;
   break;

  case 'T':
   VAR_57.c_ddate = FUNC_57(VAR_48);
   if (VAR_57.c_ddate < 0) {
    (void)FUNC_15(VAR_58, "bad time \"%s\"\n",
        VAR_48);
    FUNC_13(VAR_22);
   }
   VAR_85 = 1;
   VAR_42 = -1;
   break;

  case 'u':
   VAR_66 = 1;
   break;

  case 'W':
  case 'w':
   FUNC_27(VAR_78);
   FUNC_13(VAR_21);

  default:
   FUNC_59();
  }
 VAR_69 -= VAR_49;
 VAR_70 += VAR_49;

 if (VAR_69 < 1) {
  (void)FUNC_15(VAR_58, "Must specify disk or file system\n");
  FUNC_13(VAR_22);
 }
 VAR_33 = *VAR_70++;
 VAR_69--;
 if (VAR_69 >= 1) {
  (void)FUNC_15(VAR_58, "Unknown arguments to dump:");
  while (VAR_69--)
   (void)FUNC_15(VAR_58, " %s", *VAR_70++);
  (void)FUNC_15(VAR_58, "\n");
  FUNC_13(VAR_22);
 }
 if (VAR_53 && (VAR_43 > 0)) {
  (void)FUNC_15(VAR_58, "%s %s\n", "rsync friendly options",
      "can be used only with level 0 dumps.");
  FUNC_13(VAR_22);
 }
 if (VAR_85 && VAR_66) {
         (void)FUNC_15(VAR_58,
      "You cannot use the T and u flags together.\n");
  FUNC_13(VAR_22);
 }
 if (VAR_52) {
  VAR_59 = "child pipeline process";
 } else if (VAR_59 == ((void*)0) && (VAR_59 = FUNC_20("TAPE")) == ((void*)0))
  VAR_59 = VAR_23;
 if (FUNC_49(VAR_59, "-") == 0) {
  VAR_51++;
  VAR_59 = "standard output";
 }

 if (VAR_27)
  VAR_27 = FUNC_39(VAR_27, VAR_47);
 else if (!VAR_67) {
  if (VAR_30 == 0)
   VAR_30 = VAR_29 ? 100 : 160;
  if (VAR_64 == 0)
   VAR_64 = VAR_29 ? 1700L*120L : 2300L*120L;
 }

 if (FUNC_48(VAR_59, ':')) {
  VAR_40 = VAR_59;
  VAR_59 = FUNC_48(VAR_40, ':');
  *VAR_59++ = '\0';
  (void)FUNC_15(VAR_58, "remote dump not enabled\n");
  FUNC_13(VAR_22);

 }
 (void)FUNC_43(FUNC_25());

 if (FUNC_44(VAR_10, VAR_15) != VAR_15)
  FUNC_44(VAR_10, VAR_55);
 if (FUNC_44(VAR_14, VAR_15) != VAR_15)
  FUNC_44(VAR_14, VAR_55);
 if (FUNC_44(VAR_9, VAR_15) != VAR_15)
  FUNC_44(VAR_9, VAR_55);
 if (FUNC_44(VAR_8, VAR_15) != VAR_15)
  FUNC_44(VAR_8, VAR_55);
 if (FUNC_44(VAR_12, VAR_15) != VAR_15)
  FUNC_44(VAR_12, VAR_55);
 if (FUNC_44(VAR_13, VAR_15) != VAR_15)
  FUNC_44(VAR_13, VAR_55);
 if (FUNC_44(VAR_11, VAR_41) == VAR_15)
  FUNC_44(VAR_11, VAR_15);

 FUNC_8();






 VAR_75 = FUNC_17(VAR_33);
 if (VAR_75 != ((void*)0)) {
  VAR_33 = FUNC_37(VAR_75->fs_spec);
   if (VAR_33 == ((void*)0))
    FUNC_12(VAR_22, "%s: unknown file system", VAR_75->fs_spec);
  (void)FUNC_52(VAR_57.c_dev, VAR_75->fs_spec, VAR_6);
  (void)FUNC_52(VAR_57.c_filesys, VAR_75->fs_file, VAR_6);
 } else {
  (void)FUNC_52(VAR_57.c_dev, VAR_33, VAR_6);
  (void)FUNC_52(VAR_57.c_filesys, "an unlisted file system",
      VAR_6);
 }
 VAR_57.c_dev[VAR_6-1]='\0';
 VAR_57.c_filesys[VAR_6-1]='\0';

 if ((VAR_77 = FUNC_23(VAR_33, &VAR_80)) != ((void*)0)) {
  if (VAR_80 & VAR_5) {
   if (VAR_56 != 0) {
    FUNC_30("WARNING: %s\n",
        "-L ignored for read-only filesystem.");
    VAR_56 = 0;
   }
  } else if (VAR_56 == 0) {
   FUNC_30("WARNING: %s\n",
       "should use -L when dumping live read-write "
       "filesystems!");
  } else {
   char VAR_90[VAR_0], VAR_91[VAR_0];

   FUNC_45(VAR_90, sizeof VAR_90, "%s/.snap", VAR_77);
   if ((FUNC_47(VAR_90, &VAR_71) < 0) || !FUNC_1(VAR_71.st_mode)) {
    FUNC_30("WARNING: %s %s\n",
        "-L requested but snapshot location",
        VAR_90);
    FUNC_30("         %s: %s\n",
        "is not a directory",
        "dump downgraded, -L ignored");
    VAR_56 = 0;
   } else {
    FUNC_45(VAR_90, sizeof VAR_90,
        "%s/.snap/dump_snapshot", VAR_77);
    FUNC_45(VAR_91, sizeof VAR_91, "%s %s %s",
        VAR_26, VAR_77, VAR_90);
    FUNC_58(VAR_90);
    if (FUNC_54(VAR_91) != 0)
     FUNC_12(VAR_22, "Cannot create %s: %s\n",
         VAR_90, FUNC_51(VAR_38));
    if ((VAR_34 = FUNC_34(VAR_90, VAR_7)) < 0) {
     FUNC_58(VAR_90);
     FUNC_12(VAR_22, "Cannot open %s: %s\n",
         VAR_90, FUNC_51(VAR_38));
    }
    FUNC_58(VAR_90);
    if (FUNC_18(VAR_34, &VAR_71) != 0)
     FUNC_11(VAR_22, "%s: stat", VAR_90);
    VAR_57.c_date = FUNC_3(VAR_71.st_mtime);
   }
  }
 } else if (VAR_56 != 0) {
  FUNC_30("WARNING: Cannot use -L on an unmounted filesystem.\n");
  VAR_56 = 0;
 }
 if (VAR_56 == 0) {
  if ((VAR_34 = FUNC_34(VAR_33, VAR_7)) < 0)
   FUNC_11(VAR_22, "Cannot open %s", VAR_33);
  if (FUNC_18(VAR_34, &VAR_71) != 0)
   FUNC_11(VAR_22, "%s: stat", VAR_33);
  if (FUNC_1(VAR_71.st_mode))
   FUNC_12(VAR_22, "%s: unknown file system", VAR_33);
 }

 (void)FUNC_50(VAR_57.c_label, "none");
 (void)FUNC_21(VAR_57.c_host, VAR_6);
 VAR_57.c_level = VAR_43;
 VAR_57.c_type = VAR_20;
 if (VAR_53) {

  VAR_57.c_date = 0;
  VAR_57.c_ddate = 0;
 }
 if (VAR_57.c_date == 0) {
  VAR_89 = "the epoch\n";
 } else {
  time_t VAR_92 = FUNC_2(VAR_57.c_date);
  VAR_89 = FUNC_7(&VAR_92);
 }
 FUNC_30("Date of this level %d dump: %s", VAR_43, VAR_89);

 if (!VAR_85 && (!VAR_53))
         FUNC_19();
 if (VAR_57.c_ddate == 0) {
  VAR_89 = "the epoch\n";
 } else {
  time_t VAR_93 = FUNC_2(VAR_57.c_ddate);
  VAR_89 = FUNC_7(&VAR_93);
 }
 if (VAR_42 < 0)
  FUNC_30("Date of last (level unknown) dump: %s", VAR_89);
 else
  FUNC_30("Date of last level %d dump: %s", VAR_42, VAR_89);

 FUNC_30("Dumping %s%s ", VAR_56 ? "snapshot of ": "", VAR_33);
 if (VAR_75 != ((void*)0))
  FUNC_31("(%s) ", VAR_75->fs_file);
 if (VAR_40)
  FUNC_31("to %s on host %s\n", VAR_59, VAR_40);
 else
  FUNC_31("to %s\n", VAR_59);

 FUNC_53();
 if ((VAR_82 = FUNC_41(VAR_34, &VAR_54, VAR_16)) != 0) {
  switch (VAR_82) {
  case 128:
   FUNC_60("Cannot find file system superblock");
   return (1);
  default:
   FUNC_60("Unable to read file system superblock");
   return (1);
  }
 }
 VAR_32 = VAR_54->fs_fsize / FUNC_16(VAR_54, 1);
 VAR_31 = FUNC_14(VAR_32) - 1;
 if (VAR_32 != (1 << VAR_31))
  FUNC_36("dev_bsize (%ld) is not a power of 2", VAR_32);
 VAR_63 = FUNC_14(VAR_17) - 1;
 if (VAR_17 != (1 << VAR_63))
  FUNC_36("TP_BSIZE (%d) is not a power of 2", VAR_17);
 VAR_88 = VAR_54->fs_ipg * VAR_54->fs_ncg;
 VAR_44 = FUNC_40(FUNC_26(VAR_88, VAR_1), VAR_17);
 VAR_68 = (char *)FUNC_6((unsigned) VAR_44, sizeof(char));
 VAR_36 = (char *)FUNC_6((unsigned) VAR_44, sizeof(char));
 VAR_37 = (char *)FUNC_6((unsigned) VAR_44, sizeof(char));
 VAR_60 = 3 * (FUNC_26(VAR_44 * sizeof(char), VAR_17) + 1);

 VAR_45 = VAR_57.c_level < VAR_86;

 VAR_50 = 1;
 FUNC_42("%s: pass 1: regular files", VAR_33);
 FUNC_30("mapping (Pass I) [regular files]\n");
 VAR_83 = FUNC_29(VAR_88, &VAR_60);

 VAR_50 = 2;
 FUNC_42("%s: pass 2: directories", VAR_33);
 FUNC_30("mapping (Pass II) [directories]\n");
 while (VAR_83) {
  VAR_83 = FUNC_28(VAR_88, &VAR_60);
 }

 if (VAR_51 || VAR_67) {
  VAR_60 += 10;
  FUNC_30("estimated %ld tape blocks.\n", VAR_60);
 } else {
  double VAR_94;

  if (VAR_27)
   VAR_94 = (double) VAR_60 / VAR_27;
  else if (VAR_29) {




   VAR_94 =
   ( (double) VAR_60
    * VAR_17
    * (1.0/VAR_30)
     +
      (double) VAR_60
    * (1.0/VAR_47)
    * 15.48
   ) * (1.0 / VAR_64 );
  } else {


   int VAR_95 = (VAR_30 == 625) ? 3 : 7;
   VAR_94 =
   ( (double) VAR_60
    * VAR_17
    * (1.0/VAR_30)
     +
      (double) VAR_60
    * (1.0/VAR_47)
    * VAR_95
   ) * (1.0 / VAR_64 );
  }
  VAR_39 = VAR_94;
  VAR_39++;

  VAR_60 += (VAR_39 - 1) *
   (FUNC_26(VAR_44 * sizeof(char), VAR_17) + 1);
  VAR_60 += VAR_39 + 10;
  FUNC_30("estimated %ld tape blocks on %3.2f tape(s).\n",
      VAR_60, VAR_94);
 }





        if (VAR_87)
                FUNC_13(0);




 if (!FUNC_4())
  FUNC_36(
 "can't allocate tape buffers - try a smaller blocking factor.\n");

 FUNC_46(1);
 (void)FUNC_55((time_t *)&(VAR_65));
 FUNC_10(VAR_68, VAR_18, VAR_88 - 1);

 VAR_50 = 3;
 FUNC_42("%s: pass 3: directories", VAR_33);
 FUNC_30("dumping (Pass III) [directories]\n");
 VAR_73 = 0;
 for (VAR_76 = VAR_36, VAR_72 = 1; VAR_72 < VAR_88; VAR_72++) {
  if (((VAR_72 - 1) % VAR_1) == 0)
   VAR_73 = *VAR_76++;
  else
   VAR_73 >>= 1;
  if ((VAR_73 & 1) == 0)
   continue;



  VAR_74 = FUNC_22(VAR_72, &VAR_79);
  if (VAR_79 != VAR_4)
   continue;
  (void)FUNC_9(VAR_74, VAR_72);
 }

 VAR_50 = 4;
 FUNC_42("%s: pass 4: regular files", VAR_33);
 FUNC_30("dumping (Pass IV) [regular files]\n");
 for (VAR_76 = VAR_37, VAR_72 = 1; VAR_72 < VAR_88; VAR_72++) {
  if (((VAR_72 - 1) % VAR_1) == 0)
   VAR_73 = *VAR_76++;
  else
   VAR_73 >>= 1;
  if ((VAR_73 & 1) == 0)
   continue;



  VAR_74 = FUNC_22(VAR_72, &VAR_79);
  if (VAR_79 == VAR_4)
   continue;
  (void)FUNC_9(VAR_74, VAR_72);
 }

 (void)FUNC_55((time_t *)&(VAR_62));
 VAR_57.c_type = VAR_19;
 for (VAR_81 = 0; VAR_81 < VAR_47; VAR_81++)
  FUNC_61(VAR_88 - 1);
 if (VAR_51)
  FUNC_30("DUMP: %jd tape blocks\n", (intmax_t)VAR_57.c_tapea);
 else
  FUNC_30("DUMP: %jd tape blocks on %d volume%s\n",
      (intmax_t)VAR_57.c_tapea, VAR_57.c_volume,
      (VAR_57.c_volume == 1) ? "" : "s");


 if (VAR_62 - VAR_65 == 0)
  FUNC_30("finished in less than a second\n");
 else
  FUNC_30("finished in %jd seconds, throughput %jd KBytes/sec\n",
      (intmax_t)VAR_62 - VAR_65,
      (intmax_t)(VAR_57.c_tapea /
      (VAR_62 - VAR_65)));

 FUNC_35();
 FUNC_56();
 FUNC_5("DUMP IS DONE!\a\a\n");
 FUNC_30("DUMP IS DONE\n");
 FUNC_0(VAR_21);

}
