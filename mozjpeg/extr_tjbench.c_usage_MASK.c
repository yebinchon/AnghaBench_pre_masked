
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


struct TYPE_2__ {int num; int denom; } ;


 int FUNC_0 (int) ;
 int VAR_0 ;
 int FUNC_1 (char*,...) ;
 TYPE_1__* VAR_1 ;

void FUNC_2(char *VAR_2)
{
  int VAR_3;

  FUNC_1("USAGE: %s\n", VAR_2);
  FUNC_1("       <Inputfile (BMP|PPM)> <Quality> [options]\n\n");
  FUNC_1("       %s\n", VAR_2);
  FUNC_1("       <Inputfile (JPG)> [options]\n\n");
  FUNC_1("Options:\n\n");
  FUNC_1("-alloc = Dynamically allocate JPEG image buffers\n");
  FUNC_1("-bmp = Generate output images in Windows Bitmap format (default = PPM)\n");
  FUNC_1("-bottomup = Test bottom-up compression/decompression\n");
  FUNC_1("-tile = Test performance of the codec when the image is encoded as separate\n");
  FUNC_1("     tiles of varying sizes.\n");
  FUNC_1("-rgb, -bgr, -rgbx, -bgrx, -xbgr, -xrgb =\n");
  FUNC_1("     Test the specified color conversion path in the codec (default = BGR)\n");
  FUNC_1("-cmyk = Indirectly test YCCK JPEG compression/decompression (the source\n");
  FUNC_1("     and destination bitmaps are still RGB.  The conversion is done\n");
  FUNC_1("     internally prior to compression or after decompression.)\n");
  FUNC_1("-fastupsample = Use the fastest chrominance upsampling algorithm available in\n");
  FUNC_1("     the underlying codec\n");
  FUNC_1("-fastdct = Use the fastest DCT/IDCT algorithms available in the underlying\n");
  FUNC_1("     codec\n");
  FUNC_1("-accuratedct = Use the most accurate DCT/IDCT algorithms available in the\n");
  FUNC_1("     underlying codec\n");
  FUNC_1("-progressive = Use progressive entropy coding in JPEG images generated by\n");
  FUNC_1("     compression and transform operations.\n");
  FUNC_1("-subsamp <s> = When testing JPEG compression, this option specifies the level\n");
  FUNC_1("     of chrominance subsampling to use (<s> = 444, 422, 440, 420, 411, or\n");
  FUNC_1("     GRAY).  The default is to test Grayscale, 4:2:0, 4:2:2, and 4:4:4 in\n");
  FUNC_1("     sequence.\n");
  FUNC_1("-quiet = Output results in tabular rather than verbose format\n");
  FUNC_1("-yuv = Test YUV encoding/decoding functions\n");
  FUNC_1("-yuvpad <p> = If testing YUV encoding/decoding, this specifies the number of\n");
  FUNC_1("     bytes to which each row of each plane in the intermediate YUV image is\n");
  FUNC_1("     padded (default = 1)\n");
  FUNC_1("-scale M/N = Scale down the width/height of the decompressed JPEG image by a\n");
  FUNC_1("     factor of M/N (M/N = ");
  for (VAR_3 = 0; VAR_3 < VAR_0; VAR_3++) {
    FUNC_1("%d/%d", VAR_1[VAR_3].num, VAR_1[VAR_3].denom);
    if (VAR_0 == 2 && VAR_3 != VAR_0 - 1) FUNC_1(" or ");
    else if (VAR_0 > 2) {
      if (VAR_3 != VAR_0 - 1) FUNC_1(", ");
      if (VAR_3 == VAR_0 - 2) FUNC_1("or ");
    }
    if (VAR_3 % 8 == 0 && VAR_3 != 0) FUNC_1("\n     ");
  }
  FUNC_1(")\n");
  FUNC_1("-hflip, -vflip, -transpose, -transverse, -rot90, -rot180, -rot270 =\n");
  FUNC_1("     Perform the corresponding lossless transform prior to\n");
  FUNC_1("     decompression (these options are mutually exclusive)\n");
  FUNC_1("-grayscale = Perform lossless grayscale conversion prior to decompression\n");
  FUNC_1("     test (can be combined with the other transforms above)\n");
  FUNC_1("-copynone = Do not copy any extra markers (including EXIF and ICC profile data)\n");
  FUNC_1("     when transforming the image.\n");
  FUNC_1("-benchtime <t> = Run each benchmark for at least <t> seconds (default = 5.0)\n");
  FUNC_1("-warmup <t> = Run each benchmark for <t> seconds (default = 1.0) prior to\n");
  FUNC_1("     starting the timer, in order to prime the caches and thus improve the\n");
  FUNC_1("     consistency of the results.\n");
  FUNC_1("-componly = Stop after running compression tests.  Do not test decompression.\n");
  FUNC_1("-nowrite = Do not write reference or output images (improves consistency of\n");
  FUNC_1("     performance measurements.)\n");
  FUNC_1("-stoponwarning = Immediately discontinue the current\n");
  FUNC_1("     compression/decompression/transform operation if the underlying codec\n");
  FUNC_1("     throws a warning (non-fatal error)\n\n");
  FUNC_1("NOTE:  If the quality is specified as a range (e.g. 90-100), a separate\n");
  FUNC_1("test will be performed for all quality values in the range.\n\n");
  FUNC_0(1);
}
