
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_4__ TYPE_2__ ;
typedef struct TYPE_3__ TYPE_1__ ;


struct uffdio_copy {long long src; long long dst; long long len; scalar_t__ mode; } ;
struct TYPE_3__ {long long address; } ;
struct TYPE_4__ {TYPE_1__ pagefault; } ;
struct uffd_msg {TYPE_2__ arg; } ;
struct thread_struct {int count; int fd; } ;
struct subprocess_info {void* cleanup; scalar_t__ path; } ;
struct pollfd {int fd; int events; int revents; } ;
typedef int msg ;


 scalar_t__ VAR_0 ;
 int VAR_1 ;
 int VAR_2 ;
 int VAR_3 ;
 int VAR_4 ;
 int VAR_5 ;
 int VAR_6 ;
 int VAR_7 ;
 scalar_t__ VAR_8 ;
 int FUNC_0 (int) ;
 int FUNC_1 (int ,char*) ;
 int FUNC_2 (int,int ,struct uffdio_copy*) ;
 int FUNC_3 (char*,char,int) ;
 void* FUNC_4 (void*,int,int,int,int,int ) ;
 int FUNC_5 (void*,int) ;
 int VAR_9 ;
 int FUNC_6 (char*) ;
 int FUNC_7 (struct pollfd*,int,int) ;
 int FUNC_8 (int,struct uffd_msg*,int) ;
 int FUNC_9 (void*,int,int) ;
 int VAR_10 ;

void *FUNC_10(void *VAR_11) {
 struct thread_struct *VAR_12 = VAR_11;
 int VAR_13 = VAR_12->count;

 int VAR_14 = VAR_12->fd;

 for (;;) {
  struct uffd_msg VAR_15;

  struct pollfd VAR_16[1];
  VAR_16[0].fd = VAR_12->fd;
  VAR_16[0].events = VAR_4;
  int VAR_17;

  VAR_17 = FUNC_7(VAR_16, 1, -1);
  switch (VAR_17) {
  case -1:
   FUNC_6("poll userfaultfd");
   continue;
   break;
  case 0: continue; break;
  case 1: break;
  default:
   FUNC_0(2);
  }
  if (VAR_16[0].revents & VAR_3) {
   FUNC_0(1);
  }
  if (!(VAR_16[0].revents & VAR_4)) {
   continue;
  }

  int VAR_18;
  VAR_18 = FUNC_8(VAR_14, &VAR_15, sizeof(VAR_15));

  if (VAR_18 == -1) {
   if (VAR_8 == VAR_0)
    continue;
   FUNC_6("read userfaultfd");
  }

  if (VAR_18 != sizeof(VAR_15)) {
   FUNC_1(VAR_10, "short read, not expected, exiting\n");
   FUNC_0(1);
  }

  long long VAR_19 = VAR_15.arg.pagefault.address;
      char VAR_20[VAR_9];
  long *VAR_21 = (long *)VAR_20;


  FUNC_3(VAR_20, 'B', VAR_9);

  struct uffdio_copy VAR_22;
  VAR_22.src = (long long)VAR_20;
  VAR_22.dst = (long long)(VAR_19 & ~(0x1000 - 1));
  VAR_22.len = (long long)VAR_9;
  VAR_22.mode = 0;

  void *VAR_23;

  if (VAR_13 != 3) {
   if (VAR_13 % 2)
    VAR_23 = (void *)(0x40000000 & ~(0x1000 - 1));
   else
    VAR_23 = (void *)((0x40000000 & ~(0x1000 - 1)) + 0x1000);


   FUNC_5(VAR_23, 0x1000);
      void *VAR_24 = FUNC_4(VAR_23, 0x1000, VAR_5|VAR_6, VAR_2|VAR_1, -1, 0);
   FUNC_9(VAR_23, 0x1000, ++VAR_13);
  } else {

   struct subprocess_info *VAR_25 = (struct subprocess_info *)(0x40000000 + 0x1000 - 88);
   VAR_25->path = 0;
   VAR_25->cleanup = (void *)0xdeadbeef;
  }

   if (FUNC_2(VAR_14, VAR_7, &VAR_22) == -1) {
   FUNC_6("ioctl(UFFDIO_COPY)");
  }
 }
 return ((void*)0);
}
