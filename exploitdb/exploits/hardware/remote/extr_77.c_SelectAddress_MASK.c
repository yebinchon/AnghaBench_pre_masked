
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_7__ TYPE_4__ ;
typedef struct TYPE_6__ TYPE_3__ ;
typedef struct TYPE_5__ TYPE_1__ ;


typedef int consider ;
struct TYPE_5__ {unsigned int a; int count; } ;
typedef TYPE_1__ addrs_t ;
struct TYPE_7__ {int strategy; } ;
struct TYPE_6__ {unsigned int addrc; unsigned int nop_offset; unsigned int lastaddr; TYPE_1__* addrs; } ;


 scalar_t__ VAR_0 ;
 int VAR_1 ;
 int VAR_2 ;





 TYPE_4__ VAR_3 ;
 int FUNC_0 (int ,char*) ;
 TYPE_3__ VAR_4 ;
 int FUNC_1 (TYPE_1__**,int ,int) ;
 int FUNC_2 (char*,unsigned int,...) ;
 float FUNC_3 () ;
 int FUNC_4 (unsigned long) ;
 int VAR_5 ;
 scalar_t__ FUNC_5 (int *) ;

unsigned int FUNC_6(void) {
unsigned int VAR_6;
int VAR_7;
unsigned int VAR_8,VAR_9;
addrs_t VAR_10;
addrs_t VAR_11[VAR_1];
unsigned int VAR_12=0;

if (VAR_4.addrc==0) {
FUNC_0(VAR_5,"ERROR: No addresses available. Unable to recover\n");
return 0;
}
for (VAR_8=0;VAR_8<VAR_4.addrc;VAR_8++)
FUNC_2(" Address 0x%08X (%u times)\n",
VAR_4.addrs[VAR_8].a,
VAR_4.addrs[VAR_8].count);





FUNC_1(&VAR_11,0,sizeof(VAR_11));
for (VAR_8=0;VAR_8<VAR_4.addrc;VAR_8++) {
if (VAR_4.addrs[VAR_8].count<VAR_0) {
FUNC_2("Address 0x%08X count below threshold\n",
VAR_4.addrs[VAR_8].a);
continue;
}
VAR_11[VAR_12]=VAR_4.addrs[VAR_8];
VAR_12++;
}





if (VAR_3.strategy != 132) {
for (VAR_8=0;VAR_8<VAR_12-1;VAR_8++) {
for (VAR_9=0;VAR_9<(VAR_12-1-VAR_8);VAR_9++) {
if (VAR_11[VAR_9+1].a < VAR_11[VAR_9].a) {
VAR_10=VAR_11[VAR_9];
VAR_11[VAR_9] = VAR_11[VAR_9+1];
VAR_11[VAR_9+1] = VAR_10;
}
}
}
} else {
for (VAR_8=0;VAR_8<VAR_12-1;VAR_8++) {
for (VAR_9=0;VAR_9<(VAR_12-1-VAR_8);VAR_9++) {
if (VAR_11[VAR_9+1].count < VAR_11[VAR_9].count) {
VAR_10=VAR_11[VAR_9];
VAR_11[VAR_9] = VAR_11[VAR_9+1];
VAR_11[VAR_9+1] = VAR_10;
}
}
}
}

FUNC_2("Cleaned up, remaining addresses %u\n",VAR_12);
if (VAR_12==0) {
FUNC_0(VAR_5,"ERROR: No addresses left. Unable to recover\n"
"You can try to decrease LOW_COUNT_THR in the source\n");
return 0;
}
for (VAR_8=0;VAR_8<VAR_12;VAR_8++)
FUNC_2(" Address 0x%08X (%u times)\n",
VAR_11[VAR_8].a,
VAR_11[VAR_8].count);



switch (VAR_3.strategy) {
case 129:
{
FUNC_4((unsigned long)FUNC_5(((void*)0)));
VAR_7=(int)(((float)VAR_12-1)*FUNC_3()/(VAR_2+1.0));
VAR_6=VAR_11[VAR_7].a + VAR_4.nop_offset;
FUNC_2("Use pseudo-randomly selected address 0x%08X (0x%08X)\n",
VAR_6,VAR_11[VAR_7].a);
}
break;
case 130:
{
VAR_6=VAR_4.lastaddr + VAR_4.nop_offset;
FUNC_2("Using last address 0x%08X\n",VAR_6);
}
break;
case 128:
{
if (VAR_12==1) {
VAR_6= VAR_11[0].a + VAR_4.nop_offset;
FUNC_2("Using smallest address 0x%08X (0x%08X)\n",
VAR_6,VAR_11[0].a);
} else if (VAR_12==2) {
VAR_6= VAR_11[1].a + VAR_4.nop_offset;
FUNC_2("Using second smallest address 0x%08X (0x%08X)\n",
VAR_6,VAR_11[1].a);
} else {
VAR_6= VAR_11[2].a + VAR_4.nop_offset;
FUNC_2("Using third smallest address 0x%08X (0x%08X)\n",
VAR_6,VAR_11[2].a);
}
}
break;
case 131:
{
VAR_6= VAR_11[VAR_12-1].a + VAR_4.nop_offset;
FUNC_2("Using highest address 0x%08X (0x%08X)\n",
VAR_6,VAR_11[VAR_12-1].a);
}
break;
case 132:
{

VAR_6= VAR_11[VAR_12-1].a + VAR_4.nop_offset;
FUNC_2("Using most frequent address 0x%08X (0x%08X)\n",
VAR_6,VAR_11[VAR_12-1].a);
}
break;
default:
FUNC_0(VAR_5,"ERROR: unknown address strategy selected\n");
return (0);
}

return VAR_6;
}
